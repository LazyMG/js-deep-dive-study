# 26장. ES6 함수의 추가 기능

- 자바스크립트의 함수는 함수로서 호출될 수도 있고, `new` 연산자와 함께 호출하여 인스턴스를 생성하는 생성자 함수로도 호출할 수 있으며, 객체에 바인딩되어 메서드로도 호출할 수 있다. 자바스크립트의 함수는 다양한 형태로 사용이 가능하다.
- 이러한 유연함은 편리하다는 장점도 있지만 실수를 유발시킬 수 있으며, 성능 면에서도 손해다.
- ES6 이전의 모든 함수는 callable 하면서 constructor이기도 하다.
- ES6에서는 함수를 사용 목적에 따라 세 가지 종류(일반 함수, 메서드, 화살표 함수)로 명확하게 구분했다. 일반 함수는 기존과 같은 함수고, 메서드와 화살표 함수의 기능이 추가되었다.
- ES6에서 메서드는 메서드 축약 표현으로 정의된(`:` 없이 정의된) 함수만을 의미한다.
- ES6의 정의를 따르는 메서드는 생성자 함수가 될 수 없는 non-constructor이다. callable 하기만 하다. 때문에, `prototype` 프로퍼티가 없고, 프로토타입도 생성하지 않는다.
- ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]`를 가지며, `super` 참조는 내부 슬롯 `[[HomeObject]]`를 사용하여 수퍼 클래스의 메서드를 참조하므로 ES6 메서드는 `super` 키워드를 사용할 수 있다(ES6 이전 버전에선 `super` 키워드를 사용할 수 없다).
- 화살표 함수는 콜백 함수 내부에서 `this`가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다. 사실 상 `this` 바인딩의 혼란이 발생하는 문제를 해결하기 위해 등장한 셈이다.
- 화살표 함수는 생성자 함수로 사용할 수 없고(`prototype` 프로퍼티가 없고), 중복된 매개 변수 이름을 쓸 수 없고, 함수 자체의 `this`, `arguments`, `super`, `new.target`을 모두 갖지 않는다(정말 callable한 본연의 특성을 다 해준다). 화살표 함수에서 해당 키워드를 사용하면 가장 가까운 상위 스코프의 값을 참조하게 된다.
- 화살표 함수가 `this`를 갖지 않는 건 아예 함수가 관리하는 스코프 자체에서 `this` 바인딩에 대한 정보를 저장할 곳이 없기 때문이다. `bind`, `call`, `apply` 등 메서드로 임의로 `this`를 지정하려고 해도 `this`에 대한 정보를 저장할 공간이 없기 때문에 바인드되지 않는다.
- 메서드를 정의할 땐 ES6에 추가된 축약형 표현식, 콜백 함수 등으로 사용될 땐 화살표 함수, 상황과 목적에 맞게 함수를 정의하자.
- Rest 파라미터는 식별자 앞에 `...`를 추가하여 매개 변수를 받는 방식을 의미한다. `...args`라고 하면 `args`에는 매개 변수들의 값이 배열로 저장되며, 이는 매개 변수의 개수와 전혀 상관이 없다.
- ES5까지는 가변 인자 함수의 매개 변수를 `arguments` 객체로 받아서 함수 내부에서 지역 변수처럼 사용할 수 있었다. `arguments`는 유사 배열 객체로, 배열 메서드를 사용하려면 배열로 `Array.prototype.call` 등으로 배열로 반환을 해준 후 적용해야 했다. 하지만, Rest 파라미터는 값을 배열로 받기 때문에 변환 없이 배열 고차 함수 등을 자유롭게 사용할 수 있다.
- 화살표 함수는 `arguments` 객체가 없기 때문에, 가변 인자 함수를 구현하려면 반드시 Rest 파라미터를 사용해야 한다.
- 함수 매개 변수에 기본값을 정의하는 것도 ES6에서 추가되었으며, Rest 파라미터로 받는 가변 인자 변수도 `( ...args = [] )`과 같은 식으로 초기화가 가능하다.

# 27장. 배열

- 배열은 순서와 `length`를 갖는 객체다. 순서와 길이 정보가 있다는 것은 다른 객체와 구분되는 배열만의 고유한 특징이다.
- 배열에 포함된 데이터가 연속된 메모리 주소를 점유하고 있으면 '밀집 배열', 연속되지 않고 다음 인덱스 값의 주소를 참조하는 식으로 관리되면 '희소 배열'이라고 한다. 자바스크립트의 배열은 희소 배열로 구현되어있다.
- 배열의 `length` 프로퍼티는 0 이상의 값을 가지며, 요소가 추가되거나 삭제되면 자동으로 갱신된다.
- 배열에 특정 인덱스 값을 빼놓고 넣으면 해당 값은 `empty`로 된다. `length`는 차지하지만 값을 갖지 않는 상태이며, 이는 메모리에 공간은 점유하지만 값을 넣지 않은 상태와 유사하다.
- 배열의 요소엔 인덱스로 접근할 수 있으며, 존재하지 않는 인덱스에 접근하면 `undefined`가 반환된다. 희소 배열의 존재하지 않는 요소를 참조해도 `undefined`가 반환된다.
- 배열도 객체이기 때문에 `delete` 연산자로 값을 삭제할 수 있다. 단, `length`에는 영향을 미치지 않으며, 값이 삭제된 자리는 `empty`로 존재한다. 이는 의도한 동작이 아닌 경우가 많아서, 값을 삭제할 땐 `delete	` 연산자가 아니라 `splice` 또는 `slice`를 사용해 필요 없는 값을 잘라내는 식으로 해야한다.
- `Array.prototype`은 다양한 배열 메서드들을 제공한다. 각 메서드들의 활용 방식을 잘 이해하는 게 중요하다. 특히, 원본 배열을 바꾸는 부수 효과가 있는 메서드인지 아닌지를 잘 파악해둬야 한다.
- `pop`, `push`, `unshift`, `shift` 등은 원본 배열을 바꾸는 메서드들이다. 의도하고 사용해야 하며, 가급적 전개 연산자,`slice`, `splice,` `concat` 등을 사용해서 처리하는 게 안전하다.
- `splice`를 사용하면 배열 인덱스 부분 중간에 값을 삭제-추가 할 수 있다. 단, `splice`도 원본 배열을 변경하는 메서드이니 사용에 주의하자.
- `slice` 메서드는 배열을 얕은 복사 해준다. 원하는 구간을 매개 변수로 전달하면 해당 구간에 있는 값들을 복사해서 별도 배열로 반환한다(원본 배열을 변경하지 않는다).
- `flat` 메서드는 배열을 평탄화한다. 인수로 숫자형 값을 전달하면 전달한 숫자의 깊이만큼 재귀적으로 반복하여 평탄화를 수행해준다. 인수를 생략하면 기본값은 1이다.
- 배열 고차 함수 중 `some`은 인수로 전달한 콜백 함수의 반환값이 한 번이라도 참이면 `true`, 한 번도 참이 아니면 `false`를 반환한다. 배열 내부에 원하는 조건의 값이 1개 이상 있는지 판별하는 경우에 활용 가능하다.
- 반대로, 배열 고차 함수 `every`는 인수로 전달한 콜백 함수의 반환값 모두가 참이면 `true`, 한 번이라도 참이 아니면 `false`를 반환한다. 배열 내부에 원하는 조건에 해당하지 않는 값이 1개 이상 있는지 판별하는 경우에 활용 가능하다.
- `some`을 빈 배열에서 호출하면 언제나 `false`, `every`를 빈 배열에서 호출하면 언제나 `true`가 나온다.
