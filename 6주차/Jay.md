# 24장. 클로저

- 렉시컬 스코프가 가능하려면 함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경에 대한 정보를 기억하고 있어야 한다(호출이 아니라, 오직 정의된 위치만이 중요하다).
- 이를 위해 함수는 자신의 내부 슬롯 `[[Environment]]`에 자신이 정의된 환경에 대한 참조를 저장한다.
- `[[Environment]]`에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 상위 스코프다. 이는 함수 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 '외부 렉시컬 환경에 대한 참조'에 저장될 참조값이다.
- 함수 본문 평가 시 '외부 렉시컬 환경에 대한 참조'는 함수 객체의 내부 슬롯 `[[Environment]]`에 저장된 렉시컬 환경의 참조가 할당된다.
- 중첩 함수가 있고, 중첩 함수가 외부로 리턴되어서, `outer` 함수보다 생명 주기가 더 긴 경우가 있다. 이런 경우엔 중첩 함수 `inner`의 내부 슬롯 `[[Environment]]`에 있는 자신이 정의된 환경에 대한 참조에 남아있는 `outer` 환경의 변수를 참조할 수 있다.

```Javascript
const x = 1;

function outer() {
	const x = 10;
	const inner = function () { console.log(x) }; // 10
	return inner // 내부 함수를 외부로 리턴
}

const innerFunc = outer(); // 내부 함수를 변수에 별도로 저장하고 outer 함수는 생명 주기 종료
innerFunc(); // 10
```

- 함수의 내부 슬롯 `[[Environment]]`에 저장된 상위 스코프에 대한 정보는 함수의 생명 주기가 끝나지 않는 이상 계속 유지된다. `[[Environment]]` 내부 슬롯에 참조되었던 '외부 렉시컬 환경에 대한 참조'에 해당하는 상위 스코프가 실행 컨텍스트에서 종료되도 `[[Environment]]` 내부 슬롯에 저장된 값은 유지된다.
- 상위 스코프에 대한 정보가 `[[Environment]]`에 참조된 경우, 상위 스코프가 종료되어도 '렉시컬 환경'은 소멸하지 않는다. 메모리는 참조가 있는 식별자가 확보한 공간을 Garbage Collecting 대상에서 제외한다.
- 해당 내용만 살펴보면, 실행 컨텍스트가 만들어지면 생성되는 '렉시컬 환경'은 실행 컨텍스트와 독립적으로 존재하는 개념이라고 생각된다. 렉시컬 환경을 반드시 실행 컨텍스트하고만 연결되는 개념으로 생각하는 게 아니라, '변수와 스코프에 대한 정보를 담고 있는 환경'이고, 생성되는 시점은 실행 컨텍스트가 만들어질 때이지만, 활용 범위는 클로저까지 확장해서 생각해야 하는 것 같다.
- 클로저는 상위 스코프의 값을 참조하면서, 하위 스코프인 함수가 상위 스코프보다 생명 주기가 길어야 한다. 이렇게 두 가지 조건을 만족하는 경우에 우리는 해당 상황을 '클로저'라고 부른다.
- 클로저는 어려운 개념이지만, 잘 사용하면 굉장히 유용하다. 대표적으로, 관리되어야 하는 상태에 자유롭게 접근하지 못하도록 은닉화하는 경우에 사용이 가능하다. 관리되어야 하는 상태를 외부 함수 스코프의 변수로 만들고, 중첩 함수에서 외부 함수의 상태를 참조한 후 리턴하면 관리되어야 하는 변수에는 다른 방법으론 접근하지 못하고 오직 외부로 반환된 중첩 함수를 통해서 정해진 방식대로만 접근이 가능하다. 아래는 `num`이라는 상태를 클로저로 안전하게 관리해주는 예시이다.

```Javascript
const increase = (function () {
	let num = 0;

	return function() {
		return ++num;
	};
}());

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

# 25장. 클래스

- 클래스는 사실 함수이며, 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕(Syntactic Sugar)이다.
- 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만, 동작이 정확히 일치하진 않는다.
- 클래스는 `class` 키워드를 사용하여 정의한다. 클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 보통 사용한다. 클래스와 생성자 함수의 정의 방식은 형태적인 면에서 매우 유사하다.
- 클래스는 `Constructor`이고, 함수로는 호출될 수 없기 때문에, `new` 연산자와 같이 호출되지 않으면 에러가 발생한다.
- 인스턴스 프로퍼티는 `constructor` 메서드 내부에 정의되어야 하고, 인스턴스에 상속 되어질 메서드는 함수 내부에 별도로 정의, 정적 메서드는 `static` 키워드를 추가해서 정의한다.
- `constructor`는 인스턴스를 생성하고 초기화하기 위한 특수 메서드이며, 이름을 변경할 수 없다. 또한, `constructor`는 인스턴스의 메서드로 해석되지 않으며, 클래스가 평가되어 생성한 함수 객체의 코드 일부가 된다. 즉, 클래스 정의가 평가되면 `constructor`의 기술된 동작을 하는 함수 객체가 생성된다.
- `constructor`는 클래스 내에 최대 한 개만 존재할 수 있다. 2개 이상 존재하면 에러가 발생하며, 하나도 없을 순 있다. `constructor` 메서드를 생략하면 빈 `constructor`가 암묵적으로 정의되며, 빈 객체를 생성한다.
- `constructor` 메서드 내부에서 `this`에 추가된 프로퍼티는 인스턴스의 프로퍼티가 된다.
- 클래스는 `return`을 별도로 정의하지 않아도 암묵적으로 생성될 인스턴스 객체를 가리키는 `this`가 반환된다. 만약에 임의로 `return`문을 정의하면 인스턴스가 생성되지 않고 별도 반환한 값이 생성된다(반환한 값이 객체이면 그렇고, 원시 값이면 무시된다)
- 클래스 몸체에서 `static` 키워드 없이 정의한 메서드는 자동으로 프로토타입 메서드가 된다. 그리고, 클래스로 생성한 인스턴스는 자동으로 프로토타입 체인의 일원이 된다.
- `static` 키워드를 붙인 메서드는 클래스의 정적 메서드가 된다. 인스턴스에서는 해당 메서드를 사용할 수 없고, 클래스에서 호출할 수 있다.
- 프로토타입 메서드와 정적 메서드 사이에는 `this` 바인딩이 다르다. 메서드에서의 `this`는 자신을 호출한 주체를 가리키기 때문에, 프로토타입 메서드는 인스턴스(물론, 클래스에서 호출했다면 클래스를 가리킨다), 정적 메서드는 클래스를 가리킨다.
- 클래스를 하나의 네임 스페이스로 사용해서 정적 메서드를 모아놓으면 이름 충돌 가능성을 줄여주고 함수들을 구조화할 수 있다. 이러한 이유로, 정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수를 전역 함수로 정의하지 않고 메서드로 구조화할 때 유용하다.
- 클래스의 메서드는 아래와 같은 특징이 있다.
  - 메서드 축약 표현으로 정의한다.
  - 메서드 정의 시 다른 메서드와 구분할 때 콤마(`,`)가 필요 없다.
  - 암묵적으로 Strict mode가 적용된다.
  - `for ... in` 문이나 `Object.keys` 메서드 등으로 열거할 수 없다. 즉, `[[Enumerable]]`이 `false`이다.
  - 클래스의 메서드는 `[[Constructor]]`를 갖지 않는 `non-constructor`이고, 따라서 `new` 연산자와 함께 호출할 수 없다.
- 클래스 내부에 있는 메서드 앞에 `get`이나 `set`을 붙여주면 접근자 프로퍼티로 사용할 수 있다. `get`은 내부에 있는 정보 조회, `set`은 내부에 있는 정보 수정 역할을 해준다.
- `getter`와 `setter` 메서드는 프로토타입의 프로퍼티이며, `getter`는 반드시 반환값이 있어야 하고, `setter`는 반드시 매개변수가 있어야 한다.
- 자바스크립트 최신 문법으로 클래스 필드가 추가될 것으로 보인다. 프로퍼티를 `constructor` 내부에서 `this`와 함께 선언하지 않고, `constructor`를 제외한 클래스 본문에서 선언하더라도 인스턴스의 프로퍼티가 될 수 있다.
- 인스턴스를 생성할 때 외부 초기값으로 클래스 필드를 초기화할 필요가 있다면 `constructor`에서 인스턴스 프로퍼티를 정의하는 기존 방식을 사용하고, 인스턴스를 생성할 때 외부 초기값으로 클래스 필드를 초기화할 필요가 없다면 클래스 필드 정의 제안을 사용할 수 있다.
- 또한, 자바스크립트 최신 문법으로 캡슐화를 지원해주는 `private` 필드가 제안되어 있다. `private` 필드는 정의-참조할 때 `#`을 붙여줘야 하며, 그렇게 만들어준 필드는 클래스 내부에서만 참조된다(클래스 외부에서 참조가 불가하다).
- `private`는 반드시 클래스 몸체에 정의되어야 하며, `constructor`에 정의되면 에러가 발생한다.
- 클래스를 상속할 땐 `class {상속 받을 클래스 이름} extends {상속할 클래스 이름}` 형태로 활용한다. 말 그대로 상속할 클래스를 확장(`extends`)해서 새로운 클래스를 만들어낸다. 이때, 상속을 통해 확장된 클래스를 서브 클래스, 부모가 되는 상속된 클래스를 수퍼(베이스) 클래스라고 한다.
- `super`를 호출하면 수퍼 클래스(부모 클래스)의 `constructor`를 호출한다. `super`를 참조하면 수퍼 클래스(부모 클래스) 자체가 참조되며, 메서드를 호출할 수 있다.
- 서브 클래스의 `constructor`를 생략하면 자동으로 `constructor(super(...args))`와 같은 `constructor`가 존재하는 것처럼 동작한다. 즉, 부모의 `constructor`와 자동으로 연결이 된다.
- 하지만, 자식의 `constructor`를 임의로 정의하면서 부모의 `constructor`의 값을 가져오고 싶다면 별도로 `super(...args)`를 호출해줘야 한다.
