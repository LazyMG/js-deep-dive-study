# 📌 04장 변수

## 📚 4.1 변수란 무엇인가?

### 변수

변수는 하나의 값을 저장하기 위해 확보한 메모리 고강 자체 또는 그 메모리 공간을 식발하기 위해 붙인 이름이다.

- 즉, 값의 위치를 가리키는 상징적인 이름이다.

변수에 값을 저장하는 것을 **할당**이라 하고, 변수에 저장된 값을 읽어 들이는 것을 **참조**라 한다.

## 📚 4.2 식별자

### 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

- 변수이름을 식별자라고도 한다.

식별자는 값이 아니라 메모리 주소를 기억하고 있다.
변수, 함수, 클래스 등의 이름은 모두 식별자이다.

## 📚 4.3 변수 선언

- **변수 선언**이란 변수를 생성하는 것을 말한다.
  - 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간이 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.
- 변수를 사용하려면 반드시 선언이 필요하다.
  - var, let, const 키워드 사용

### 변수 선언 과정

1. **선언 단계** : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. **초기화 단계** : 값을 저장힉 위한 메모리 공간을 확보하고 암묵적으로 undefinded를 할당해 초기화한다.

## 📚 4.4 변수 선언의 실행 시점과 변수 호이스팅

자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행된다.

**다음 코드를 통해서 학습해보자**

```jsx
console.log(score); // undefined

var score; // 변수 선언문
```

> 💡 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아서 먼저 실행한다.

변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라고 한다.

## 📚 4.5 값의 할당

- **변수 선언**과 **값의 할당**의 실행 시점이 다르다.
- **변수 선언**은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, **값의 할당**은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

**예시 코드**

```jsx
console.log(score); // undefined

var score; // 1. 변수 선언
score = 80; // 2. 값의 할당

console.log(score); // 80
```

## 📚 4.6 값의 재할당

- **재할당**이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.

## 📚 4.7 식별자 네이밍 규칙

### 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함 할 수 있다.
- 단, 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

### 네이밍 컨벤션

```jsx
// 카멜 케이스(camelCase)
var firstName;

// 스테이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById("myId"); // DOM 노드
var observable$ = fromEvent(document, "click"); // RxJS 옵저버블
```

- 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 **카멜 케이스**를 사용한다.
- 생성자 함수, 클래스의 이름에는 **파스칼 케이스**를 사용한다.

# 📌 05장 표현식과 문

## 📚 5.1 값

- **값**은 식(표현식)이 평가되어 생성된 결과를 말한다.

## 📚 5.2 리터럴

- **리터럴**은 사람이 이해할 수 있는 문자 또는 약속되 기호를 사용해 값을 생서아는 표기법을 말한다.

## 📚 5.3 표현식

- **표현식**은 값으로 평가될 수 있는 문이다.
  - 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
- 표현식은 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다.

## 📚 5.4 문

- **문**은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.
- 문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

## 📚 5.6 표현식인 문과 표현식이 아닌 문

### 문

- 표현식인 문 : 값으로 평가될 수 있는 문
  - 할당문
- 표현식이 아닌 문 : 값으로 평가될 수 없는 문
  - 변수 선언문

# 📌 06장 데이터 타입

- 원시 타입
  - 숫자 타입
  - 문자열 타입
  - 불리언 타입
  - undefined 타입
  - null 타입
  - 심벌 타입
- 객체 타입
  - 객체, 함수, 배열 등

## 📚 6.1 숫자 타입

- 자바스크립트는 하나의 숫자 타입만 존재한다.

## 📚 6.2 문자열 타입

- 문자열은 작은 따옴표(''), 큰따옴표("") 또는 백틱(``)으로 텍스트를 감싼다.
- 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구별하기 위해서이다.
- 자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값이다.
  - 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다.

## 📚 6.3 템플릿 리터럴

- **템플릿 리터럴**은 백틱(``)을 사용해 표현한다.

### 편리한 문자열 처리 기능

- 멀티라인 문자열
  - 템플릿 리터럴 내에서는 이스케이프 스퀸스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 잇는 그대로 적용된다.
- 표현식 삽입

```jsx
var first = "Suyeong";
var last = "Kang";
// ES6 : 표현식 삽입
console.log(`my name is ${first} ${last}`); // My name is Suyeong Kang
```

## 📚 6.4 불리언 타입

- 불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false뿐이다.

## 📚 6.5 undefined 타입

- var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화된다.

## 📚 6.6 null 타입

- 프로그래밍 언어에서 null은 변수에 값이 없다는 거을 의도적으로 명시할때 사용한다.
- 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 뜻이다.
- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.

## 📚 6.7 심벌타입

- 심벌은 변경 불가능한 원시 타입의 값이다.
- 심벌 값은 다른괎과 중복되지 않는 유일무이한 값이다.
- 따라서 주로 일므이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해서 사용한다.

```jsx
// 심별 값 생성
var key = Symbol("key");
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 잆는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = "value";
console.log(obj[key]); // value
```

## 📚 6.8 객체 타입

- 자바스크립트는 객체 기반의 언어이며, 자바스크립를 이루고 있는 거의 모든 것이 객체이다.

## 📚 6.9 데이터 타입의 필요성

### 데이터 타입이 필요한 이유

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 📚 6.10 동적 타이핑

### 동적 타이핑

- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다.
- 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.
- 자바스크립트를 **동적 타입 언어**라 한다.

### 동적 타입 언어의 변수를 사용할 때 주의 사항

- 변수는 꼭 필요한 경우에 제한적으로 사용한다.
- 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.
- 전역 변수는 최대한 사용하지 않도록 한다.
- 변수보다는 상수를 사용해 값의 변경을 억제한다.
- 변수 일므은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다. 변수 이름뿐 아니라 모든 식별자(변수, 함수, 클래스 이름 등)는 존재 이유를 파악할 수 있는 적절한 이름을 지어야 한다.

# 📌 07장 연산자

**연산자**는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.

이때 연산의 대상을 **피연산자**라 한다.

**피연산자**가 "값"이라는 명사의 역할을 한다면, **연산자**는 "피연산자를 연산하여 새로운 값을 만든다"라는 동사의 역할을 한다고 볼 수 있다.

## 📚 7.1 산술 연산자

### 이항 산술 연산자

이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.

- 이항 산술 연산자 : `+`, `-`, `*`, `/`, `%`

### 단항 산술 연산자

단항 산술 연산자는 1개의 피연사자를 산술 연산하여 숫자 값을 만든다.

- 단항 산술 연산자 : `++`, `--`, `+`, `-`

#### 증가/감소(++/--) 연산자

- 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.
- 피연산자 뒤에 위치한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가 시킨다.

```jsx
var x = 5,
  result;

// 선할당 후증가
result = x++;
console.log(result, x); // 5 6

// 선증가 후할당
result = ++x;
console.log(result, x); // 7 7

// 선할당 후감소
result = x--;
console.log(result, x); // 7 6

// 선감소 후할당
result = --x;
console.log(result, x); // 5 5
```

`+` 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.

`-` 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다.
숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.

### 문자열 연결연산자

`+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제로 변환한 후 연산을 수행한다.
이를 **암묵적 타입 변환** 또는 **타입 강제 변환**이라고 한다.

## 📚 7.2 할당 연산자

할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

- 할당 연산자 : `=`, `+=`, `-=`, `*=`, `/=`, `%=`

## 📚 7.3 비교 연산자

비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.

### 동등/일치 비교 연산자

동등 비교 연산자는 느슨한 비교를 하지만 비교 연산자는 엄격한 비교를 한다.

- **동등 비교(==) 연산자** : 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.
  - 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다.
- **일치 비교(===) 연산자** : 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.

### 대소 관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

- 대소 관계 비교 연산자 : `>`, `<`, `>=`, `<=`

## 📚 7.4 삼항 조건 연산자

삼항 조건 연산자는 조건의 평가 결과에 따라 반환할 값을 결정한다.

#### 삼항연산자 표현식

> 조건식 **?** 조건식이 true일 때 반환할 값 **:** 조건식이 false일 때 반환할 값

### 삼항 조건 연산자 표현식과 if ... else 차이

삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만 if ... else 문은 값처럼 사용할 수 없다.

```jsx
var x = 10;

// if ... else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.
var result = if(x%2){result='홀수'} else{result='짝수'}
// SyntaxError: Unexpected token if

// 삼항 조건 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.
var result = x % 2 ? '홀수' : '짝수';
console.log(result) // 짝수
```

## 📚 7.5 논리 연산자

논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다.

- 논리 연산자 : `||`, `&&`, `!`

```jsx
// 논리합(||) 연산자
true || true; // -> true
true || false; // -> true
false || true; // -> true
false || false; // -> false

// 논리곱(&&) 연산자
true && true; // -> true
true && false; // -> false
false && true; // -> false
false && false; // -> false

// 논리 부정(!) 연산자
!true; // -> false
!false; // -> true
```

## 📚 7.6 쉼표 연산자

쉼표(`,`) 연산자는 왼쪽 피 연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

## 📚 7.7 그룹 연산자

소괄호(`'()'`)로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.

따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다.

## 📚 7.8 typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.

typeof 연산자는 7가지 문자열 `string`, `number`, `boolean`, `undefined`, `symbol`, `object`, `function` 중 하나를 반환한다.
`null`을 반환하는 경우는 없으며, 함수의 경우 `function`을 반환한다.

> 💡 주의
> typeof 연산자로 null 값을 연산해 보면 `null`이 아닌 `object`를 반환한다.

## 📚 7.9 지수 연산자

지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱하여 숫자 값을 반환한다.

```jsx
2 ** 3; // -> 8
Math.pow(
  2,
  3
)(
  // -> 8

  // 음수 사용 -> ()로 묶어주기
  -5
) ** 2; // -> 25
```

# 📌 08장 제어문

제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.

## 📚 8.1 블록문

블록문은 0개 이상의 문을 중괄호로 묶은 것이다.

자바스크립트는 블록문을 하나의 실행 단위로 취급한다.

블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는드는 것에 주의해야한다.

```jsx
// 블록문
{
  var foo = 10;
}

// 제어문
var x = 1;
if (x < 10) {
  x++;
}

// 함수 선언문
function sum(a, b) {
  return a + b;
}
```

## 📚 8.2 조건문

조건문은 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)이 실행을 결정한다.

### if ... else 문

```jsx
if (조건식1) {
  // 조건식1이 참이면 이 코드 블록이 실행된다.
} else if (조건식2) {
  // 조건식2가 참이면 이 코드 블록이 실행된다.
} else {
  // 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.
}
```

else if 문과 else 문은 옵션이다.

만약 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.

### switch 문

switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.
swtich 문의 표현식과 일치하는 case문이 없다면 실행 순서는 default 문으로 이동한다. default 문은 선택사항으로, 사용할 수도 있고 사용하지 않을 수도 있다.

```jsx
switch (표현식) {
  case 표현식1:
    // 문의 표현식과 표현식1이 일치하면 실행될 문
    break;
  case 표현식2:
    // 문의 표현식과 표현식2이 일치하면 실행될 문
    break;
  default:
  // 문의 표현식과 일치하는 case 문이 없을 때 실행될 문
}
```

- **폴스루** : switch 문이 끝날 때까지 이후의 모든 case문과 default 문을 실행하는 경우

> 💡 **if ... else 문 vs switch 문**

- if ... else 문 : if ... else 문의 조건식은 값으로 평가되어야 한다.
  - 논리적 참, 거짓으로 실행할 코드 블록을 결정한다.
- switch 문 : switch 문의 표현식은 불리언 값돠는 문자열이나 숫자 값인 경우가 많다.
  - 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.

## 📚 8.3 반복문

반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 시랭한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다.

- 반복문 : for 문, while 문, do...while 문

### for 문

```jsx
for(변수 선언문 또는 할당문; 조건식;증감식){
  조건식이 참인 경우 반복 실행될 문;
}
```

#### for문 동작과정

1. 변수 선언문
2. 조건식 판단
3. 실행문
4. 증감문
5. 2~4번 반복

for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다.

### while 문

while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계쏙해서 반복 실행한다.

> 💡 **for문 vs while 문**

- for 문 : 반복 횟수가 명확할 때 주로 사용
- while 문 : 반복 횟수가 불명확할 때 주로 사용

### do...while 문

do...while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 **코드 블록은 무조건 한번 이상 실행**된다.

## 📚 8.4 break 문

break 문은 레이블 문, 반복문, switch 문의 코드 블록을 탈출한다.

## 📚 8.5 continue 문

continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. break 문처럼 반복문을 탈출하지는 않는다.

# 📌 09장 타입 변환이란?

## 📚 9.1 타입 변환이란?

**타입 변환**이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.

> 💡 명시적 타입변환 vs 암묵적 타입 변환

- 명시적 타입변환(타입 캐스팅) : 개발자가 의도적으로 값의 타입을 변환하는것
- 암묵적 타입변환(타입 강제 변환) : 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변화는 것

## 📚 9.2 암묵적 타입 변환

암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.

### 문자열 타입으로 변환

```jsx
1 +
  "2" // -> '12'
  `1 + 1 = ${1 + 1}`; // -> '1 + 1 = 2'
```

### 불리언 타입으로 변환

자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으록 구분한다.

> 💡 false로 평가되는 Fasly 값

- false
- undefined
- null
- 0, -0
- NaN
- ''(빈 문자열)

Falsy 값 외의 모든 값은 모두 true로 평가되는 Truty 값이다.

## 📚 9.3 명시적 타입 변환

### 명시적으로 타입을 변경하는 방법

1. 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법
2. 빌트인 메서드를 사용하는 방법
3. 암묵적 타입 변환을 이용하는 방법

## 📚 9.4 단축 평가

단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.

### 논리 연산자를 사용한 단축 평가

- `true || anything` -> true
- `false || anything` -> false
- `true && anything` -> anything
- `false && anything` -> false

### 옵셔널 체이닝 연산자

옵셔널 체이닝 연산자 `?.`는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

```jsx
var elem = null;

// elem이 null 또는 undefined이면 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
var value = elem?.value;
console.log(value); // undefined
```

> 💡 논리 연산자 `&&`vs 옵셔널 체이닝 연산자 `?.`

- 논리 연산자 `&&`는 좌항 연산자가 false로 평가되는 Falsy 값(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이면 좌항 피연산자를 그대로 변환한다.
- 옵셔널 체이닝 연산자 `?.`는 좌항 피연산자가 false로 평가되는 Falsy 값(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이라도 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어간다.

### null 병합 연산자

null 병합연산자 `??`는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

null 병합 연산자 `??`는 변수에 기본 값을 설정할 때 유용하다.

> 💡 논리 연산자 `||`vs null 병합연산자 `??`

- 논리 연산자 `||`를 사용한 다축 평가의 경우 좌항의 피연산자가 false로 평가되는 Falsy 값(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이면 우항의 피연산자를 반환한다.
- null 병합연산자 `??`는 좌항 피연산자가 false로 평가되는 Falsy 값(`false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`)이라도 null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환한다.
