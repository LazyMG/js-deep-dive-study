# ✍️ 공부한 내용 정리

## 4장 변수

### 💡 자바스크립트의 변수 초기화

자바스크립트 엔진은 변수 선언을 **2단계**에 걸쳐 수행합니다.

> - 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
> - 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 **undefined**를 할당해 초기화

여기서 자바스크립트의 독특한 특징이 드러나는데요, 바로 **변수의 초기화**입니다.

자바스크립트의 **초기화 단계**는 암묵적으로 `undefined`라는 값을 할당하는 과정이 수행됩니다.

다음은 **var** 키워드를 사용한 변수 선언 예시입니다. 변수를 선언한 이후, 아직 변수에 값을 할당하지 않았습니다.

```javascript
var score; // 변수 선언(변수 선언문)
```

변수에 값을 할당하지 않았기 때문에 **선언 단계**를 통해 확보된 메모리 공간이 비어 있을 것으로 생각할 수 있지만 확보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화 됩니다.

위 코드 예시처럼 **var** 키워드를 사용한 변수 선언은 **선언 단계**와 **초기화 단계**가 동시에 진행됩니다. **var score;**는 선언 단계를 통해 변수 이름 score를 등록하고, 값을 저장할 메모리 공간을 확보합니다. 그 후 **초기화 단계**를 통해 score 변수에 `undefined`를 할당해 초기화합니다.

그렇다면 자바스크립트 엔진은 왜 undefined를 변수에 할당할까요?

> 만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에 쓰레기 값이 남아있을 수 있습니다. 자바스크립트의 var 키워드는 암묵적으로 초기화를 수행하므로 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하여 쓰레기 값이 나올 수 있는 위험으로부터 안전합니다.

또다른 변수 선언 키워드 **let**도 암묵적 초기화의 대상입니다. **var**과 **let**의 차이는 뒷 챕터에서 더 자세히 알아봅니다.

```javascript
let score; // 변수 선언(변수 선언문)

console.log(score); // undefined
```

### 💡 Referece Error

변수를 사용하려면 반드시 선언이 필요합니다. 변수뿐만 아니라 모든 식별자(함수, 클래스 등)도 동일합니다. 만약 선언하지 않은 식별자에 접근하면 `ReferenceError(참조 에러)`가 발생합니다. `ReferenceError`는 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러입니다.

<img src="https://velog.velcdn.com/images/cbfmark/post/1ed4feb5-bfdd-4844-a462-9f249684b1cc/image.png" width="50%"/>

<br/>

### 💡 변수 호이스팅

위에서 사용했던 예시로 더 알아봅시다. 해당 코드를 실행하면 에러가 발생하지 않습니다.

```javascript
console.log(score); // undefined

var score; // 변수 선언문
```

> _엥? 선언하지 않은 식별자에 접근하면 참조 에러가 발생한다고 했는데?_

코드를 자세히 살펴보죠. 변수 선언문(var score;)보다 변수를 참조하는 코드(console.log(score);)가 앞에 있습니다. 자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 **console.log(score);** 가 가장 먼저 실행되고 순차적으로 다음 줄에 있는 코드가 실행됩니다. 따라서 console.log(score);가 실행되는 시점에는 아직 score 변수의 선언이 실행되지 않았으니까 참조 에러가 발생할 것처럼 보입니다. 하지만 결과는 참조 에러가 아니라 `undefined`가 출력됩니다.

> 그 이유는 **변수 선언이** 소스코드가 한 줄싹 순차적으로 실행되는 시점, 즉 **런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문**입니다.

자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 합니다. 이때 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행합니다. 그리고 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행합니다.

즉, 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행합니다. 따라서 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있습니다.

위 예시 코드에 적용해서 생각한다면 다음과 같습니다.

```javascript
// var score;  // 호이스팅된 위치

console.log(score); // undefined

var score; // 실제 변수 선언문
```

이렇게 생각한다면 실행 결과에 납득할 수 있겠죠?

> 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라고 합니다.

사실 변수 선언뿐 아니라 var, let, const, function, function\*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅 됩니다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문입니다.

주의할 점은 함수 호이스팅의 경우 **함수 선언문**이 호이스팅의 대상이지, **함수 표현식**은 호이스팅이 되지 않는다는 것입니다. 이와 관련된 내용은 뒷 챕터에서 자세하게 알아봅니다.

```javascript
// 함수 선언문
console.log(add(1, 2)); // 3

function add(x, y) {
  return x + y;
}
```

```javascript
// 함수 표현식
console.log(add(1, 2)); // error

var add = function (x, y) {
  return x + y;
};
```

에러 내용

<img src="https://velog.velcdn.com/images/cbfmark/post/3ecceea3-ebfa-4024-9a37-0f7b312c539d/image.png" width="60%"/>

<br/>

### 💡 변수의 선언과 값의 할당

이제 변수 호이스팅도 알아봤으니 좀 더 깊게 들어가보겠습니다.

다음은 변수에 값을 할당하는 예시입니다. 변수 선언과 값의 할당을 하나의 문으로 단축 표현할 수 있습니다.

```javascript
var score = 80; // 변수 선언과 값의 할당
```

변수 선언과 값의 할당을 2개의 문으로 나누어 표현한 코드와 변수 선언과 값의 할당을 하나의 문으로 단축 표현한 코드는 정확히 동일하게 동작합니다.

```javascript
// 위에랑
var score = 80; //// 변수 선언과 값의 할당을 하나의 문으로

// 아래랑 같아요
var score; //// 변수 선언과
score = 80; //// 값의 할당을 별도로
```

즉, 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행합니다. 너무 당연한 말 같지 않은가요?

하지만 이때 자바스크립트에서 주의할 점이 있습니다. 바로 변수 선언과 값의 할당의 실행 시점이 다르다는 것입니다. 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당을 소스코드가 순차적으로 실행되는 시험인 런타임에 실행됩니다. 아래의 예시에서 살펴보겠습니다.

```javascript
console.log(score); // undefined

var score; // ① 변수 선언
score = 80; // ② 값의 할당

console.log(score); // 80
```

변수 선언(①)은 런타임 이전에 먼저 실행되고 값의 할당(②)은 런타임에 실행됩니다. 변수 호이스팅이 적용된 것이죠. 따라서 score 변수에 값을 할당하는 시점(②)에는 이미 변수 선언이 완료된 상태이며, 이미 `undefined`로 초기화되어 있습니다. 따라서 score 변수에 값을 할당하면 score 변수의 값은 `undefined`에서 새롭게 할당한 숫자 값 80으로 변경(재할당)됩니다.

아래의 예시처럼 호이스팅이 적용된다고 생각하면 쉽습니다.

```javascript
// var score;  // 호이스팅된 변수 선언
console.log(score); // undefined

var score; // 실제 변수 선언
score = 80; // 값의 할당

console.log(score); // 80
```

변수 선언과 값의 할당을 하나의 문으로 단축 표현할 수도 있으므로 앞 예시 코드는 다음 코드와 동일하게 동작합니다.

```javascript
console.log(score); // undefined

var score = 80; // 변수 선언과 값의 할당

console.log(score); // 80
```

> 변수의 선언과 값의 할당을 하나의 문장으로 단축 표현해도 자바스크립트 엔진은 변수의 선언과 값의 할당을 2개의 문으로 나누어 각각 실행합니다. 따라서 변수에 `undefined`가 할당되어 초기화되는 것은 변함이 없습니다.

다음 예시 코드의 결과에 납득이 된다면 이해하신 겁니다!

```javascript
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score); // 답: 80
```

<br/>

### 📑 4장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- 변수의 암묵적 초기화 (undefined)
- 변수 호이스팅
- 변수 선언과 값의 할당 실행 순서

<br/>

## 5장 표현식과 문

### 💡 값

> **값은 식(표현식)이 평가되어 생성된 결과를 말합니다.** 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미합니다.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름입니다. 따라서 **변수에 할당되는 것은 값**입니다.

```javascript
// 10 + 20은 평가되어 숫자 30을 생성합니다.
var sum = 10 + 20;
```

<br/>

### 💡 표현식

> **표현식은 값으로 평가될 수 있는 문입니다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조합니다.**

```javascript
// 값으로 평가될 수 있는 문은 모두 표현식입니다.

// 리터럴 표현식
10;
("hello");

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum;
person.name;
arr[1];

// 연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수, 메서드 호출 표현식(선언이 이미 존재한다고 가정)
square();
person.getName();
```

<br/>

### 💡 표현식인 문과 표현식이 아닌 문

표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있습니다. 다음 예시 코드를 살펴봅시다.

```javascript
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닙니다.
var x;

// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식입니다.
// x = 1 + 2는 표현식이면서 완전한 문이기도 합니다.
x = 1 + 2;
```

이처럼 표현식인 문과 표현식이 아닌 문은 비슷하기 때문에 구별하기 어렵다고 느낄 수 있습니다. 하지만 구별하는 방법은 간단합니다. 앞선 용어들의 정의를 다시 살펴봅시다.

> - 표현식은 값으로 평가될 수 있는 문이다.

- 변수에 할당되는 것은 값이다.

앞선 용어들의 정의들로 내릴 수 있는 결론은 변수에 할당할 수 있으면 표현식인 문이고 할당할 수 없으면 표현식이 아닌 문입니다. 다음 예시 코드를 살펴봅시다.

```javascript
// 표현식이 아닌 문은 값처럼 사용할 수 없습니다.
var foo = var x;  // error
```

위 코드 예시에서 알 수 있듯이 변수 선언문은 변수에 할당할 수 없기 때문에 표현식이 아닙니다. 이는 값으로 사용할 수 없다는 의미와 같습니다.

```javascript
// 변수 선언문은 표현식이 아닌 문입니다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 합니다. 즉, 할당문은 표현식인 문입니다.
x = 100;

// 표현식인 문은 값처럼 사용할 수 있습니다.
var foo = (x = 100);
console.log(foo); // 100
```

<br/>

### 💡 완료 값

크롬 개발자 도구에서 간단한 자바스크립트 코드를 실행하다보면 `undefined`를 자주 보게됩니다. 콘솔을 찍었는데 출력되는 별 의미 없는 `undefined`의 존재가 의문이었습니다.

크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 `undefined`를 출력합니다. 이를 **완료 값**이라고 합니다. 즉, 표현식인 문은 평가된 값이 있기 때문에 개발자 도구에서 실행하면 평가된 값을 출력하고 표현식이 아닌 문은 `undefined`를 출력한다는 것이죠.

> 표현식인 문의 완료 값 : 평가된 값
> 표현식이 아닌 문의 완료 값 : undefined

그럼 몇 가지 예시들을 살펴보겠습니다.

console.log는 값을 출력하지만 반환 값이 없으므로 완료 값은 undefined가 됩니다.

<img src="https://velog.velcdn.com/images/cbfmark/post/0b8ab1e0-eeed-4850-8bff-0ca9ac5d2d8f/image.png" width="30%"/>

변수 선언문은 반환 값이 없어 완료 값이 `undefined`가 되지만 변수 할당문은 반환 값이 할당 값이 되기 때문엔 완료 값은 할당 값이 됩니다.

<img src="https://velog.velcdn.com/images/cbfmark/post/0a0e2cfd-8a75-4da8-b6ac-e09814cbd044/image.png" width="20%"/>

변수 선언과 할당을 동시에 할 경우 자바스크립트 엔진은 var y = 100;에서 변수 선언의 완료 값을 우선시하여 `undefined`를 반환하게 됩니다.

<img src="https://velog.velcdn.com/images/cbfmark/post/b1e43ce4-5293-4468-9fc7-e561f96e4ea8/image.png" width="30%"/>

조건문의 경우 반환 값이 없기 때문에 완료 값이 `undefined`가 됩니다. 내부에 console.log가 값을 출력하지만 console.log 또한 반환 값이 없습니다. 이 경우, 자바스크립트는 하나의 문에 대해 하나의 완료 값만 반환하기 때문에 완료 값은 전체 조건문의 완료 값인 `undefined`가 됩니다.

<img src="https://velog.velcdn.com/images/cbfmark/post/6b46894d-e815-4ccd-b640-b454915eef1c/image.png" width="30%"/>

<br/>

### 📑 5장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- 표현식인 문과 표현식이 아닌 문
- 완료 값

<br/>

## 6장 데이터 타입

### 💡 템플릿 리터럴

ES6부터 **템플릿 리터럴**이라고 하는 새로운 문자열 표기법이 도입되었습니다. 템플릿 리터럴은 편리한 문자열 처리 기능을 제공합니다. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리됩니다.

템플릿 리터럴은 일반 문자열과 비슷해 보이지만 백틱을(``) 사용해 표현합니다.

```javascript
var template = `Template literal`;
console.log(template); // Template literal
```

템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있습니다. 이를 통해 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할 수 있습니다.

```javascript
var first = "maga";
var last = "Lee";

console.log(`My name is ${first} ${last}.`); // My name is maga Lee.
```

<br/>

### 💡 undefined 타입

undefined 타입의 값은 `undefined`가 유일합니다.

앞서 설명했듯이 var 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화됩니다. 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 `undefined`가 반환됩니다.

유의해야 할 점은 `undefined`는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값이라는 것입니다.

개발자가 의도적으로 변수에 `undefined`를 할당하는 것은 `undefined`의 본래 취지에 어긋날뿐더러 혼란을 줄 수 있으므로 권장되지 않습니다.

의도적으로 변수에 값이 없다는 것을 명시하고 싶다면 `null`을 할당하는 것이 좋습니다.

<br/>

### 💡 null 타입

null 타입의 값은 `null`이 유일합니다.

프로그래밍 언어에서 `null`은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용합니다. 변수에 `null`을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미입니다. 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것입니다.

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반환하기도 합니다.

<br/>

### 📑 6장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- 자바스크립트의 데이터 타입
- 템플릿 리터럴
- undefined와 null의 차이점

<br/>

## 7장 연산자

### 💡 비교 연산자

자바스크립트의 비교 연산자 중에 `==`과 `===`이 있습니다.

먼저 `==`은 **동등 비교**라고 합니다. **동등 비교는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교합니다.** 따라서 동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환합니다.

```javascript
// 동등 비교
5 == 5; // true

5 == "5"; // true
```

동등 비교 연산자는 예측하기 어려운 결과를 만들어내기 때문에 사용하지 않는 편이 좋습니다. 대신 **일치 비교(===)** 연산자를 사용합니다.

**일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환합니다.** 즉, 암묵적 타입 변환을 하지 않고 값을 비교합니다.

```javascript
// 일치 비교
5 === 5; // true

5 === "5"; // false
```

일치 비교 연산자에서 주의할 것은 NaN입니다. 따라서 숫자가 NaN인지 확인하려면 빌트인 함수 isNaN을 사용해야합니다.

```javascript
// NaN은 자신과 일치하지 않는 유일한 값입니다.
NaN === NaN; // false

isNaN(NaN); // true
isNaN(10); // false
isNaN("hello"); // true
```

숫자 0도 주의해야합니다. 자바스크립트에는 양의 0과 음의 0이 있는데 이 둘을 비교하면 true를 반환합니다.

```javascript
// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 결과는 true입니다.
0 === -0; // true

0 == -0; // true
```

Object.is 메서드를 사용하면 NaN과 양과 음의 0의 비교 결과를 예측 가능한 결과로 알 수 있습니다.

```javascript
0 === -0; // true
Object.is(0, -0); // false

NaN === NaN; // false
Object.is(NaN, NaN); // true
```

<br/>

### 💡 삼항 조건 연산자

삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정합니다. 삼항 조건 연산자의 표현식은 다음과 같이 사용합니다.

> 조건식 ? 조건식이 true일 때 반활할 값 : 조건식이 false일 때 반환할 값

다음 예시 코드를 통해 이해를 돕겠습니다.

```javascript
var x = 2;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환됩니다.
var result = x % 2 ? "짝수" : "홀수";

console.log(result); // 짝수
```

삼항 조건 연산자의 첫 번째 피연산자는 조건식이므로 삼항 조건 연산자 표현식은 조건문입니다. 따라서 if-else문을 사용해서 삼항 조건 연산자 표현식과 유사하게 처리할 수 있습니다.

```javascript
var x = 2,
  result;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환됩니다.
if (x % 2) result = "홀수";
else result = "짝수";

console.log(result); // 짝수
```

> ** 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문입니다.**

따라서 삼항 조건 연산자 표현식은 값처럼 다른 표현식의 일부가 될 수 있어 유용합니다.

<br/>

### 📑 7장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- ==, ===, Object.is의 차이점 및 동작 예시
- 삼항 조건 연산자의 동작

<br/>

## 9장 타입 변환과 단축 평가

### 💡 타입 변환

자바스크립트의 모든 값은 타입이 있습니다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있습니다. 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환** 또는 **타입 캐스팅**이라고 합니다.

```javascript
var x = 10;

// 명시적 타입 변환
// 숫자를 문자열로 타입 캐스팅합니다.
var str = x.toString();
console.log(typeof str, str); // string, 10

// x 변수의 값이 변경된 것은 아닙니다.
console, log(typeof x, x); // number 1-
```

개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 합니다. 이를 **암묵적 타입 변환** 또는 **타입 강제 변환**이라고 합니다.

```javascript
var x = 10;

// 암묵적 타입 변환
// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성합니다.
var str = x + "";
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아닙니다.
console.log(typeof x, x); // number 10
```

<br/>

### 💡 Truthy 값과 Falsy 값

if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값으로 평가되어야 하는 표현식입니다. 자바스크립트 엔진은 조건식의 평가를 불리언 타입으로 암묵적 타입 변환합니다.

```javascript
if ("") console.log("1");
if (true) console.log("2");
if (0) console.log("3");
if ("str") console.log("4");
if (null) console.log("5");

// 2 4
```

이때 **자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분합니다.** 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환됩니다.

다음은 false로 암묵적 타입 변환되는 Falsy 값입니다.

- false
- undefined
- null
- 0, -0
- NaN
- ''(빈 문자열)

(빈 배열 및 빈 객체는 포함되지 않습니다.)

Falsy 값 외의 모든 값은 모두 true로 평가되는 Truthy 값입니다. Truthy 값과 Falsy 값은 자주 사용되는 개념이니 반드시 이해하고 넘어가야 합니다.

<br/>

### 💡 명시적 타입 변환

개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양합니다.

#### 문자열 타입으로 변환

문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과 같습니다.

1. String 생성자 함수를 new 연산자 없이 호출하는 방법
2. Object.prototype.toString 메서드를 사용하는 방법
3. 문자열 연결 연산자를 이용하는 방법

※ 2, 3번 방법을 많이 사용했습니다.

```javascript
// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
// 숫자 타입 => 문자열 타입
String(1); // "1"
String(NaN); // "NaN"
// 불리언 타입 => 문자열 타입
String(true); // "true"

// 2. Object.prototype.toString 메서드를 사용하는 방법
// 숫자 타입 => 문자열 타입
(1).toString(); // "1"
NaN.toString(); // "NaN"
// 불리언 타입 => 문자열 타입
true.toString(); // "true"

// 3. 문자열 연결 연산자를 이용하는 방법
// 숫자 타입 => 문자열 타입
1 + ""; // "1"
NaN + ""; // "NaN"
// 불리언 타입 => 문자열 타입
true + ""; // "true"
```

#### 숫자 타입으로 변환

숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 다음과 같습니다.

1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
3. +단항 산술 연산자를 이용하는 방법
4. \*산술 연산자를 이용하는 방법

※ 1, 3번 방법을 많이 사용했습니다.

```javascript
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number("10.53"); // 10.53
Number("-1"); // -1
// 불리언 타입 => 슷자 타입
Number(true); // 1

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
// 문자열 타입 => 숫자 타입
parseFloat("10.53"); // 10.53
parseInt("-1") + // -1
// 3. + 단항 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
"10.53" + // 10.53
"-1" + // -1
  // 불리언 타입 => 슷자 타입
  true; // 1

// 4. * 산술 연산자를 이용하는 방법
"10.53" * 1; // 10.53
"-1" * 1; // -1
// 불리언 타입 => 슷자 타입
true * 1; // 1
```

#### 불리언 타입으로 변환

불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 다음과 같습니다.

1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
2. ! 부정 논리 연산자를 두 번 사용하는 방법

※ 2번 방법을 많이 사용했습니다.

```javascript
// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 불리언 타입
Boolean("x"); // true
Boolean(""); // false
Boolean("false"); // true
// 숫자 타입 => 불리언 타입
Boolean(0); // false
Boolean(1); // true
Boolean(NaN); // false
Boolean(Infinity); // true
// null 타입 => 불리언 타입
Boolean(null); // false
// undefined 타입 => 불리언 타입
Boolean(undefined); // false
// 객체 타입 => 불리언 타입
Boolean({}); // true
Boolean([]); // true

// 2. ! 부정 논리 연산자를 두 번 사용하는 방법
// 문자열 타입 => 불리언 타입
!!"x"; // true
!!""; // false
!!"false"; // true
// 숫자 타입 => 불리언 타입
!!0; // false
!!1; // true
!!NaN; // false
!!Infinity; // true
// null 타입 => 불리언 타입
!!null; // false
// undefined 타입 => 불리언 타입
!!undefined; // false
// 객체 타입 => 불리언 타입
!!{}; // true
!![]; // true
```

<br/>

### 💡 논리 연산자를 사용한 단축 평가

`논리합( || )` 또는 `논리곱(&&)` 연산자의 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됩니다.

논리곱(&&) 연산자는 두 개의 피연산자가 모두 true로 평가될때 true를 반환합니다.
논리합( || ) 연산자는 두 개의 피연산자 중 하나가 true로 평가될때 true를 반환합니다.

> 논리곱 연산자(&&)와 논리합 연산자( || )는 **이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환합니다. 이를 단축 평가라고 합니다.
> 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말합니다.**

단축 평가는 다음과 같이 이해하면 쉽습니다.

- 논리합( || )
  - 좌항이 Truthy 값이면 결과는 좌항
  - 좌항이 Falsy 값이면 결과는 우항
- 논리곱(&&)

  - 좌항이 Truthy 값이면 결과는 우항
  - 좌항이 Falsy 값이면 결과는 좌항

단축 평가는 if 문을 대체하는 용도로 자주 사용됩니다.

```javascript
var flag = true;
var result = "ready";

var result = flag && "start"; // start
```

위 코드는 다음과 같이 바꿀 수 있습니다.

```javascript
var flag = true;
var result = "ready";

if (flag) result = "start"; // start
```

<br/>

### 💡 옵셔널 체이닝 연산자

`옵셔널 체이닝 연산자( .? )`는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어갑니다. 옵셔널 체이닝 연산자 이전에는 논리곱 연산자를 사용한 단축 평가를 통해 변수가 null 또는 undefined인지 확인했습니다.

옵셔널 체이닝 연산자의 장점은 좌항이 Falsy 값이어도 null 또는 undefined가 아닌 경우에는 우항의 프로퍼티 참조를 이어간다는 것입니다. 논리곱 연산자와 옵셔널 체이닝 연산자를 다음 예시를 통해 비교해보겠습니다.

```javascript
var str = "";

// 원하는 결과는 0 입니다.
var length = str && str.length; // str은 Falsy 값입니다.

console.log(length); // ''
```

```javascript
var str = "";

// 원하는 결과는 0 입니다.
var length = str?.length; // str은 null 또는 undefined가 아닙니다.

console.log(length); // 0
```

위 두 예시의 차이를 보겠습니다. 논리곱은 좌항이 Falsy 값이면 좌항을 반환하기 때문에 length에는 ''이 할당됩니다. 반면 옵셔널 체이닝 연산자는 좌항이 null 또는 undefined인지 확인하는데, 좌항이 빈 문자열이기 우항의 연산이 진행되어 length에 0이 할당됩니다.

<br/>

### 💡 null 병합 연산자

`null 병합 연산자(??)`는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환합니다. null 병합 연산자는 변수에 기본값을 설정할 때 유용합니다. null 병합 연산자 이전에는 논리합 연산자를 사용한 단축 평가를 통해 변수에 기본값을 설정했습니다.

null 병합 연산자의 장점은 좌항이 Falsy 값이어도 null 또는 undefined가 아닌 경우라면 좌항을 반환한다는 것입니다. 논리합 연산자와 null 병합 연산자를 다음 예시를 통해 비교해보겠습니다.

```javascript
// 원하는 결과는 '' 입니다.
var foo = "" || "default string";

console.log(foo); // 'default string'
```

```javascript
// 원하는 결과는 '' 입니다.
var foo = "" ?? "default string";

console.log(foo); // ''
```

만약 Falsy 값인 0이나 ''도 기본값으로 유효하다면 예기치 않은 동작이 발생할 수 있습니다.

<br/>

### 📑 9장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- 자바스크립트의 타입 변환
- Truthy 값과 Falsy 값
- 논리합( || ), 논리곱(&&) 연산자를 사용한 단축 평가
- 옵셔널 체이닝
- null 병합 연산자
