# 4장

## 변수 선언 방식

자바스크립트에서는 `var`, `let`, `const` 키워드를 사용하여 변수를 선언합니다. 각 키워드는 고유한 특징이 있으며, 사용 시 주의해야 할 점들이 존재합니다.

### 1. `var` 키워드

- ES5 이전부터 사용된 변수 선언 방식.
- **스코프**: **함수 스코프**를 가짐. 즉, 함수 내부에서만 유효하고 함수 외부에서는 접근할 수 없습니다.
- **호이스팅**: 변수 선언이 최상단으로 끌어올려지는 **호이스팅**이 발생하여, 선언 위치에 관계없이 함수 내 어디서든 사용할 수 있습니다.
- **특징**: 여러 번 선언해도 에러가 발생하지 않으며, 초기화하지 않으면 `undefined` 값을 가짐.

### 2. `let` 키워드

- ES6에서 도입된 변수 선언 방식.
- **스코프**: **블록 스코프**를 가짐. 즉, 중괄호 `{}`로 감싸진 코드 블록 내에서만 유효합니다.
- **호이스팅**: 선언이 호이스팅되지만, 선언 전에는 사용할 수 없도록 **일시적 사각지대(TDZ)**가 발생하여 선언 전에 접근하면 에러가 발생합니다.
- **특징**: `let`으로 선언된 변수는 재할당이 가능하지만, 중복 선언이 불가능합니다.

### 3. `const` 키워드

- ES6에서 도입된 상수 선언 방식.
- **스코프**: `let`과 동일한 **블록 스코프**를 가짐.
- **호이스팅**: `let`과 동일하게 일시적 사각지대가 존재합니다.
- **특징**: 상수로 선언되므로 선언 이후 **재할당이 불가능**하며, 선언과 동시에 초기화가 필수입니다.

## 변수 호이스팅 (Variable Hoisting)

자바스크립트 엔진은 코드 실행 전에 모든 변수를 먼저 컴파일하며, 이 과정에서 변수가 최상단으로 끌어올려집니다. 이러한 현상을 **변수 호이스팅**이라 하며, 변수를 선언하기 전에도 사용할 수 있게 만듭니다. 하지만 `var`와 달리 `let`과 `const`는 호이스팅되더라도 TDZ로 인해 선언 전에 접근 시 에러가 발생합니다.

### 일시적 사각지대 (Temporal Dead Zone, TDZ)

`let`과 `const`로 선언된 변수는 코드의 호이스팅 시점부터 실제 선언까지의 구간에서 사용할 수 없습니다. 이 구간을 일시적 사각지대라 부르며, 이를 통해 선언 전 변수 접근을 방지할 수 있습니다.

## 스코프(Scope)와 스코프 체인

스코프는 **변수가 유효한 코드의 영역**을 의미합니다. 자바스크립트는 **렉시컬 스코프**를 따르기 때문에, 함수를 어디서 호출하느냐가 아닌 어디서 선언했느냐에 따라 상위 스코프가 결정됩니다. 스코프는 **함수 스코프**와 **블록 스코프**로 나눌 수 있습니다.

### 스코프 체인 (Scope Chain)

자바스크립트는 변수를 참조할 때 현재 스코프에서 찾고, 존재하지 않으면 상위 스코프에서 찾는 방식으로 **스코프 체인**을 따라갑니다. 이 메커니즘 덕분에 자바스크립트는 스코프 내에서 참조가 불가능한 변수를 효율적으로 탐색할 수 있습니다.

## 변수의 생명 주기 (Lifecycle)

변수의 생명 주기는 **선언 단계**, **초기화 단계**, **할당 단계**로 나누어집니다.

1. **선언 단계**: 변수를 등록하여 자바스크립트 엔진이 이를 인식하게 만듭니다.
2. **초기화 단계**: 변수에 메모리 공간을 확보하고, `undefined`로 초기화합니다.
3. **할당 단계**: 변수에 실제 값을 할당합니다.

`var` 변수는 선언과 동시에 초기화가 이루어지지만, `let`과 `const`는 선언 후 TDZ를 거쳐 초기화됩니다. `const`는 선언과 초기화가 동시에 이루어져야 합니다.

## 값의 할당과 재할당

변수에 값을 **할당**하면 메모리에 저장되며, 이후 값을 변경하는 **재할당**이 가능합니다. `let` 변수는 재할당이 가능하지만, `const`는 선언된 값을 변경할 수 없습니다. `const` 변수에 객체나 배열을 할당한 경우, 객체나 배열의 내부 값은 변경할 수 있지만 변수 자체를 재할당할 수는 없습니다.

## 전역 변수와 네임스페이스 오염

전역 변수는 전역 스코프에서 선언된 변수로, 프로그램 전체에서 접근 가능하지만, 전역 스코프에 여러 변수가 쌓이면 **네임스페이스 오염**이 발생하여 의도치 않은 참조 문제가 생길 수 있습니다. 따라서 변수는 가급적 필요한 스코프 내에서만 선언해야 합니다.

### 암묵적 전역

키워드를 사용하지 않고 변수를 선언할 경우, 암묵적으로 전역 변수가 생성되어 의도치 않은 버그를 유발할 수 있습니다. 이를 방지하기 위해 항상 `var`, `let`, `const` 키워드를 사용하여 변수를 선언해야 합니다.

--- 

# 5장

### 1. 값

- **값**은 표현식이 평가되어 생성된 결과를 의미합니다. 모든 값은 데이터 타입을 가지며, 메모리에 2진수로 저장됩니다.

### 2. 리터럴

- **리터럴**은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법입니다. 예를 들어, 숫자 리터럴 `10`, 문자열 리터럴 `"Hello"` 등이 있습니다.

### 3. 표현식

- **표현식**은 값으로 평가될 수 있는 문을 의미합니다. 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조합니다.

  ```javascript
  // 리터럴 표현식
  10;
  'Hello';

  // 식별자 표현식 (선언이 이미 존재한다고 가정)
  sum;
  person.name;
  arr[1];

  // 연산자 표현식
  10 + 20;
  sum = 10;
  sum !== 10;

  // 함수/메서드 호출 표현식 (선언이 이미 존재한다고 가정)
  square();
  person.getName();
```

### 4. 문
- **문**은 프로그램을 구성하는 기본 단위이자 최소 실행 단위입니다. 여러 토큰으로 구성되며, 명령문이라고도 부릅니다. 예를 들어, 선언문, 할당문, 조건문, 반복문 등이 있습니다.
  
```javascript
var sum = 1 + 2;
```

### 5. 세미콜론과 세미콜론 자동 삽입 기능
- 세미콜론(;)은 문의 종료를 나타냅니다. 단, 문을 중괄호로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않습니다. 자바스크립트 엔진은 소스코드를 해석할 때 세미콜론 자동 삽입 기능(ASI)을 수행하므로, 세미콜론은 생략 가능하지만, 명시적으로 붙이는 것을 권장합니다.

### 6. 표현식인 문과 표현식이 아닌 문 
- 표현식인 문 : 값으로 평가될 수 있는 문.
- 표현식이 아닌 문 : 값으로 평가될 수 없는 문


- 표현식인 문과 표현식이 아닌 문을 구별하는 방법은 변수에 할당해 보는 것입니다. 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있지만, 표현식이 아닌 문은 값으로 평가되지 않으므로 변수에 할당하면 에러가 발생합니다.


  

