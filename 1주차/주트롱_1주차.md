# 4장

## 변수 선언 방식

자바스크립트에서는 `var`, `let`, `const` 키워드를 사용하여 변수를 선언합니다. 각 키워드는 고유한 특징이 있으며, 사용 시 주의해야 할 점들이 존재합니다.

### 1. `var` 키워드

- ES5 이전부터 사용된 변수 선언 방식.
- **스코프**: **함수 스코프**를 가짐. 즉, 함수 내부에서만 유효하고 함수 외부에서는 접근할 수 없습니다.
- **호이스팅**: 변수 선언이 최상단으로 끌어올려지는 **호이스팅**이 발생하여, 선언 위치에 관계없이 함수 내 어디서든 사용할 수 있습니다.
- **특징**: 여러 번 선언해도 에러가 발생하지 않으며, 초기화하지 않으면 `undefined` 값을 가짐.

### 2. `let` 키워드

- ES6에서 도입된 변수 선언 방식.
- **스코프**: **블록 스코프**를 가짐. 즉, 중괄호 `{}`로 감싸진 코드 블록 내에서만 유효합니다.
- **호이스팅**: 선언이 호이스팅되지만, 선언 전에는 사용할 수 없도록 **일시적 사각지대(TDZ)**가 발생하여 선언 전에 접근하면 에러가 발생합니다.
- **특징**: `let`으로 선언된 변수는 재할당이 가능하지만, 중복 선언이 불가능합니다.

### 3. `const` 키워드

- ES6에서 도입된 상수 선언 방식.
- **스코프**: `let`과 동일한 **블록 스코프**를 가짐.
- **호이스팅**: `let`과 동일하게 일시적 사각지대가 존재합니다.
- **특징**: 상수로 선언되므로 선언 이후 **재할당이 불가능**하며, 선언과 동시에 초기화가 필수입니다.

## 변수 호이스팅 (Variable Hoisting)

자바스크립트 엔진은 코드 실행 전에 모든 변수를 먼저 컴파일하며, 이 과정에서 변수가 최상단으로 끌어올려집니다. 이러한 현상을 **변수 호이스팅**이라 하며, 변수를 선언하기 전에도 사용할 수 있게 만듭니다. 하지만 `var`와 달리 `let`과 `const`는 호이스팅되더라도 TDZ로 인해 선언 전에 접근 시 에러가 발생합니다.

### 일시적 사각지대 (Temporal Dead Zone, TDZ)

`let`과 `const`로 선언된 변수는 코드의 호이스팅 시점부터 실제 선언까지의 구간에서 사용할 수 없습니다. 이 구간을 일시적 사각지대라 부르며, 이를 통해 선언 전 변수 접근을 방지할 수 있습니다.

## 스코프(Scope)와 스코프 체인

스코프는 **변수가 유효한 코드의 영역**을 의미합니다. 자바스크립트는 **렉시컬 스코프**를 따르기 때문에, 함수를 어디서 호출하느냐가 아닌 어디서 선언했느냐에 따라 상위 스코프가 결정됩니다. 스코프는 **함수 스코프**와 **블록 스코프**로 나눌 수 있습니다.

### 스코프 체인 (Scope Chain)

자바스크립트는 변수를 참조할 때 현재 스코프에서 찾고, 존재하지 않으면 상위 스코프에서 찾는 방식으로 **스코프 체인**을 따라갑니다. 이 메커니즘 덕분에 자바스크립트는 스코프 내에서 참조가 불가능한 변수를 효율적으로 탐색할 수 있습니다.

## 변수의 생명 주기 (Lifecycle)

변수의 생명 주기는 **선언 단계**, **초기화 단계**, **할당 단계**로 나누어집니다.

1. **선언 단계**: 변수를 등록하여 자바스크립트 엔진이 이를 인식하게 만듭니다.
2. **초기화 단계**: 변수에 메모리 공간을 확보하고, `undefined`로 초기화합니다.
3. **할당 단계**: 변수에 실제 값을 할당합니다.

`var` 변수는 선언과 동시에 초기화가 이루어지지만, `let`과 `const`는 선언 후 TDZ를 거쳐 초기화됩니다. `const`는 선언과 초기화가 동시에 이루어져야 합니다.

## 값의 할당과 재할당

변수에 값을 **할당**하면 메모리에 저장되며, 이후 값을 변경하는 **재할당**이 가능합니다. `let` 변수는 재할당이 가능하지만, `const`는 선언된 값을 변경할 수 없습니다. `const` 변수에 객체나 배열을 할당한 경우, 객체나 배열의 내부 값은 변경할 수 있지만 변수 자체를 재할당할 수는 없습니다.

## 전역 변수와 네임스페이스 오염

전역 변수는 전역 스코프에서 선언된 변수로, 프로그램 전체에서 접근 가능하지만, 전역 스코프에 여러 변수가 쌓이면 **네임스페이스 오염**이 발생하여 의도치 않은 참조 문제가 생길 수 있습니다. 따라서 변수는 가급적 필요한 스코프 내에서만 선언해야 합니다.

### 암묵적 전역

키워드를 사용하지 않고 변수를 선언할 경우, 암묵적으로 전역 변수가 생성되어 의도치 않은 버그를 유발할 수 있습니다. 이를 방지하기 위해 항상 `var`, `let`, `const` 키워드를 사용하여 변수를 선언해야 합니다.

--- 

# 5장

### 1. 값

- **값**은 표현식이 평가되어 생성된 결과를 의미합니다. 모든 값은 데이터 타입을 가지며, 메모리에 2진수로 저장됩니다.

### 2. 리터럴

- **리터럴**은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법입니다. 예를 들어, 숫자 리터럴 `10`, 문자열 리터럴 `"Hello"` 등이 있습니다.

### 3. 표현식

- **표현식**은 값으로 평가될 수 있는 문을 의미합니다. 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조합니다.

  ```javascript
  // 리터럴 표현식
  10;
  'Hello';

  // 식별자 표현식 (선언이 이미 존재한다고 가정)
  sum;
  person.name;
  arr[1];

  // 연산자 표현식
  10 + 20;
  sum = 10;
  sum !== 10;

  // 함수/메서드 호출 표현식 (선언이 이미 존재한다고 가정)
  square();
  person.getName();
```

### 4. 문
- **문**은 프로그램을 구성하는 기본 단위이자 최소 실행 단위입니다. 여러 토큰으로 구성되며, 명령문이라고도 부릅니다. 예를 들어, 선언문, 할당문, 조건문, 반복문 등이 있습니다.
  
```javascript
var sum = 1 + 2;
```

### 5. 세미콜론과 세미콜론 자동 삽입 기능
- 세미콜론(;)은 문의 종료를 나타냅니다. 단, 문을 중괄호로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않습니다. 자바스크립트 엔진은 소스코드를 해석할 때 세미콜론 자동 삽입 기능(ASI)을 수행하므로, 세미콜론은 생략 가능하지만, 명시적으로 붙이는 것을 권장합니다.

### 6. 표현식인 문과 표현식이 아닌 문 
- 표현식인 문 : 값으로 평가될 수 있는 문.
- 표현식이 아닌 문 : 값으로 평가될 수 없는 문


- 표현식인 문과 표현식이 아닌 문을 구별하는 방법은 변수에 할당해 보는 것입니다. 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있지만, 표현식이 아닌 문은 값으로 평가되지 않으므로 변수에 할당하면 에러가 발생합니다.

--- 

# 6장: 데이터 타입

## 6.1 데이터 타입의 필요성
- 자바스크립트는 값을 **타입**으로 구분하여 다양한 연산 수행 가능.
- 각 데이터 타입은 **저장할 수 있는 값의 종류와 의미**를 규정하며, 데이터 타입에 따라 **메모리 공간의 크기와 연산 방식**이 다름.
  
## 6.2 자바스크립트의 데이터 타입
- **원시 타입**(Primitive type): 값이 변경 불가한 불변성 특징을 가지며 6가지 기본 타입이 존재
  - **숫자**(Number): 숫자 데이터를 다루며, 정수와 실수를 구분하지 않음
  - **문자열**(String): 문자열 데이터를 다루며, 유니코드 문자의 집합
  - **불리언**(Boolean): 논리적 참(true) 또는 거짓(false)을 표현
  - **undefined**: 변수는 선언되었으나 값이 할당되지 않은 상태
  - **null**: 값이 없음을 나타내는 특별한 값
  - **심벌**(Symbol): 고유하고 변경 불가능한 값으로 객체의 프로퍼티 키로 사용
- **객체 타입**(Object type): 원시 타입을 제외한 나머지 데이터 타입으로, 여러 값을 하나의 단위로 구성 가능

## 6.3 데이터 타입의 필요성
- **타입 검사**: 자바스크립트는 동적 타입 언어로, 변수 선언 시 타입을 명시하지 않으나 실행 중 타입을 결정
- **타입 변환**: 명시적 타입 변환과 암묵적 타입 변환을 통해 자바스크립트 엔진이 상황에 맞는 타입으로 변환하여 동작
- **값과 객체**: 원시 타입은 변경 불가한 값으로 다루어지고, 객체 타입은 가변적이며 참조로 관리됨

## 6.4 불변성
- 원시 값은 **불변성**을 가지며, 이는 값이 생성된 이후 변경할 수 없다는 의미
- 객체는 변경 가능한 데이터 타입으로, 프로퍼티를 동적으로 추가, 삭제 가능

## 6.5 값에 의한 전달과 참조에 의한 전달
- **값에 의한 전달**: 원시 값은 변수에 할당될 때 복사되어 전달
- **참조에 의한 전달**: 객체는 참조 값이 전달되어 원본 데이터의 변경이 가능

## 6.6 데이터 타입의 필요성 요약
- 데이터 타입은 변수의 종류와 해당 변수가 수행할 수 있는 연산을 결정
- 자바스크립트에서 원시 타입과 객체 타입을 구분하여 다양한 프로그래밍 방식 지원

--- 

# 7장: 연산자

## 7.1 연산자의 개념
- **연산자**는 하나 이상의 표현식을 대상으로 **산술, 할당, 비교, 논리 연산** 등을 수행하여 **새로운 값을 생성**하는 기호 또는 키워드.
- 연산의 대상이 되는 값(피연산자)과 결과값이 연산을 통해 반환됨.

## 7.2 산술 연산자
- **산술 연산자**: 숫자 값을 대상으로 기본적인 산술 계산 수행
  - `+`, `-`, `*`, `/`, `%`, `**`(지수 연산)
  - **단항 산술 연산자**: 하나의 피연산자를 다룸 (ex. `++`, `--`, `+`, `-`)

## 7.3 할당 연산자
- **할당 연산자**: 변수에 값을 할당하는 연산자
  - `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=`

## 7.4 비교 연산자
- **비교 연산자**: 피연산자 간의 상대적인 크기나 동등성을 비교하여 **불리언 값** 반환
  - **동등 비교**: `==`, `!=` (타입 변환 후 비교)
  - **일치 비교**: `===`, `!==` (타입과 값이 모두 같은지 비교)
  - **대소 비교**: `<`, `>`, `<=`, `>=`

## 7.5 논리 연산자
- **논리 연산자**: 불리언 값을 조합하여 참 또는 거짓의 논리 값을 반환
  - `&&` (논리 AND), `||` (논리 OR), `!` (논리 NOT)
  - **단축 평가**(short-circuit evaluation): 논리 연산에서 불필요한 연산을 생략

## 7.6 타입 연산자
- **typeof 연산자**: 변수의 데이터 타입을 확인하여 문자열로 반환
  - `typeof` 연산자는 모든 데이터 타입에 사용 가능
- **instanceof 연산자**: 특정 객체가 어떤 생성자 함수의 인스턴스인지 확인

## 7.7 삼항 조건 연산자
- **삼항 조건 연산자**(`condition ? expr1 : expr2`): 조건에 따라 반환할 값을 선택하는 연산자로, 간단한 조건문 대신 사용 가능.

## 7.8 그 외의 연산자
- **콤마 연산자**(`,`): 두 개 이상의 표현식을 순차적으로 평가하며, 마지막 값이 반환됨.
- **그룹 연산자**(`()`): 연산자의 우선순위를 명시적으로 조정.
- **null 병합 연산자**(`??`): `null` 또는 `undefined`인 경우 우측 피연산자 반환.

## 7.9 연산자의 우선순위와 결합 순서
- 자바스크립트는 **연산자의 우선순위와 결합 순서**를 통해 연산 순서를 결정.
  - 우선순위가 높은 연산자가 먼저 실행되며, 동일한 우선순위의 연산자는 **결합 순서**에 따라 처리.

## 7.10 연산자 요약
- 연산자는 코드의 동작을 결정하는 중요한 요소로, 각 연산자의 역할과 특징을 이해하면 더 효율적이고 가독성 높은 코드를 작성할 수 있음.

--- 

# 8장: 제어문

## 8.1 블록문
- **블록문**은 `{}`로 감싸진 코드 블록으로, **여러 개의 문을 하나로 그룹화**할 때 사용.
- 함수나 조건문, 반복문 등에서 자주 사용되며, 하나의 문(statement)으로 취급됨.

## 8.2 조건문
- 조건에 따라 코드의 실행 흐름을 제어하는 **제어문**.

### 8.2.1 if 문
- 조건이 **true**일 때 코드 블록을 실행.
- **if...else**: 조건이 false일 경우 대체 코드 블록을 실행.
- **if...else if...else**: 여러 조건을 순차적으로 검사하고 해당 조건을 만족할 때 코드 블록을 실행.

### 8.2.2 switch 문
- 변수 값에 따라 **여러 케이스** 중 하나를 선택하여 실행.
- 주로 **동등 비교**(`===`)를 기반으로 하며, 많은 조건이 필요한 경우 if 문보다 가독성이 좋음.
- `break` 문을 통해 실행을 중단하지 않으면 **fall-through**가 발생해 다음 케이스도 실행됨.

## 8.3 반복문
- 특정 조건이 **참인 동안** 코드 블록을 반복 실행.

### 8.3.1 for 문
- 반복 횟수가 명확할 때 사용.
- **초기화문**, **조건문**, **증감문**을 통해 제어.

### 8.3.2 while 문
- 조건이 **참일 때** 코드 블록을 반복 실행.
- 반복 횟수가 명확하지 않을 때 주로 사용.

### 8.3.3 do...while 문
- 코드 블록을 **최소 한 번** 실행한 후 조건을 검사하여 반복 여부 결정.
  
### 8.3.4 for...in 문
- 객체의 **열거 가능한 프로퍼티 키**를 반복.
- 배열에는 권장되지 않으며, 객체 순회에 사용됨.

### 8.3.5 for...of 문
- **이터러블 객체(배열, 문자열 등)**의 요소를 반복.
- 이터러블 프로토콜을 따르는 모든 객체에서 사용 가능.

## 8.4 break 문
- **반복문이나 switch 문의 실행을 중단**하고, 코드 흐름을 다음 문으로 이동.
- 주로 반복문에서 특정 조건을 만족할 때 반복을 중지하기 위해 사용.

## 8.5 continue 문
- **반복문의 현재 실행을 중단하고**, 반복문의 **다음 반복을 수행**.
- 특정 조건을 만족할 때 해당 반복을 건너뛰기 위해 사용.

## 8.6 레이블 문
- 식별자가 붙은 문(statement)을 실행할 수 있도록 허용.
- 복잡한 중첩 루프에서 특정 위치로 **break** 또는 **continue** 시 유용하나, 사용은 권장되지 않음.

## 8.7 제어문 요약
- **제어문**은 코드의 흐름을 제어하고 반복이나 조건에 따라 코드의 실행을 분기.
- 제어문을 통해 효율적이고 목적에 맞는 프로그램 흐름을 작성할 수 있으며, 가독성 및 유지보수성이 높은 코드를 구성하는 데 도움을 줌.




  

