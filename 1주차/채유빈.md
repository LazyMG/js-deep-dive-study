# 목차

1. [변수](#4장.-변수)
2. [표현식과 문](#5장-표현식과-문)
3. [데이터 타입](#6장-데이터-타입)
4. [연산자](#7장-연산자)
5. [제어문](#8장-제어문)
6. [타입 변환과 단축 평가](#9장-타입-변환과-단축-평가)

<br>

# 4장. 변수

## 변수가 왜 필요할까?

컴퓨터는 인간과 달리 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.
메모리는 데이터를 저장할 수 있는 **메모리 셀(memory cell)의 집합체**이다. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 1바이트 단위로 데이터를 저장하거나 읽어들인다.
각 셀은 고유의 메모리 주소(memory address)를 가지며, 메모리 주소는 곧 메모리 공간의 위치이다.

> 🤔 만약 메모리에 저장된 어떠한 값을 재사용하고 싶다면?

가능한 방법은 하나 뿐이다. 메모리 주소를 통해 메모리 공간에 직접 접근해야 한다.
그러나 이 방법의 경우 두 가지 문제점이 있는데,

1. 만약 실수로 잘못된 메모리 주소에 접근했는데, 그 주소가 운영체제가 사용하고 있는 값인 경우 시스템이 멈추는 등 치명적인 오류가 발생할 수 있다.
2. 값이 저장될 메모리 주소는 같은 컴퓨터라도 코드를 실행할 때마다 임의로 결정되므로 코드가 실행되기 전까지는 메모리 주소를 알 수 없다.

따라서 <u>메모리에 저장된 값을 안전하게 읽어들이고 재사용하기 위해</u> 변수라는 메커니즘이 탄생했다.

<br/>

## 변수란?

정리하면 **변수(variable)**는 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

변수와 자주 혼용되는 용어가 있는데, 바로 식별자이다.

**식별자(identifier)**는 어떤 값(변수, 함수, 클래스 등)을 구별해서 식별할 수 있는 **고유한 이름**을 말한다. 식별하기 위해서는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 한다.
→ 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.

> 코어 자바스크립트에서는 ‘변수’와 ‘식별자’의 차이를 아래와 같이 언급하고 있다.

    - 변수(variable): 변경 가능한 데이터가 담길 수 있는 공간
    - 식별자(identifier): 데이터가 담긴 공간의 이름(=변수명)

자바스크립트는 식별자를 만들 때 아래와 같은 규칙을 지켜야 한다.

- 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있다.
- 그러나 숫자로 시작하는 것은 허용되지 않는다.
- 예약어는 식별자로 사용할 수 없다.
- 변수의 존재 목적을 이해할 수 있는 명확한 이름을 사용하는 것이 좋다.
- 네이밍 컨벤션
  - **camelCase** 주로 변수, 함수명에 사용
  - **PascalCase** - 생성자 함수, 클래스명에 사용
  - snake_case
  - typeHungarianCase (ex. strFirstName (type + identifier))

<br/>

## 변수를 선언하는 방법(variable declaration)

변수 선언이란 변수를 생성하는 것을 말한다. 변수를 선언할 때는 `var`, `let`, `const` 키워드를 사용한다.

```js
var score;
let score;
const score;
```

자바스크립트 엔진은 변수 선언을 두 단계를 거쳐 수행한다.

1. 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다. (실행 컨텍스트에 등록)
2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고, 암묵적으로 undefined를 할당해 초기화한다.

<br/>

### 변수 선언의 실행 시점, 호이스팅

```js
console.log(score); // undefined
var score; // 변수 선언
```

코드를 한 줄씩 실행한다고 생각하면, 1행을 실행할 때는 score에 대한 정보가 없기 때문에 에러가 발생해야 한다.
그러나 변수 선언은 런타임(runtime)이 아니라 **그 이전 단계**(변수 정보를 수집하는 과정)에서 이루어지기 때문에 1행에서 `ReferenceError`가 발생하는 대신 `undefined`가 출력된다.

즉, 변수 선언이 가장 먼저 실행되기 때문에 소스 코드의 어디서든지 변수를 참조할 수 있다.

> 이처럼 <u>변수 선언문이 코드의 선두로 끌어올려진(hoist) 것처럼 동작하는 자바스크립트 고유의 특징</u>을 **변수 호이스팅(variable hoisting)**이라고 한다.
> (변수 호이스팅은 나중에 별도의 포스트로 작성해서 연결해 둘 예정이다.)

<br/>

## 변수에 값 할당(assignment)하기

```js
var score; // 변수 선언
score = 80; // 값의 할당
```

변수 선언과 값의 할당은 실행 시점이 다르다. 변수 선언은 런타임 이전에 먼저 실행되지만, **값의 할당은 런타임에 실행**된다.

```tsx
console.log(score); // undefined

var score; // 변수 선언
score = 80; // 값의 할당

console.log(score); // 80
```

<br/>

### 변수에 값을 재할당하기

```tsx
var score; // undefined
score = 30; // 재할당 1
score = 80; // 재할당 2
```

이때 `30`이 담겨있는 공간의 값이 `80`으로 바뀌는 것이 아니라, 새로운 공간에 `80`이 할당된다. 따라서 `undefined`, `30`이 담겨있는 공간은 그 어떤 식별자와도 연결되어 있지 않은, 불필요한 값이 된다.

> 이러한 불필요한 값들은 `가비지 콜렉터`에 의해 메모리에서 자동 해제된다. (=공간이 비워진다.) 그로써 메모리 누수를 방지한다.

<br>

# 5장. 표현식과 문

## 값(value)

값(value)이란, **표현식(expression)이 평가(evaluate)되어 생성된 결과**를 말한다.

```js
10 + 20; // 10 + 20은 평가되어 숫자 값 30을 생성한다.
```

값을 생성하는 가장 기본적인 방법은 리터럴을 사용하는 것이다.
그렇다면 리터럴은 또 뭘까?

<br>

### 리터럴(literal)

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 **표기법(notation)**을 말한다.

```js
3; // 숫자 리터럴 3
```

자바스크립트 엔진은 코드가 실행되는 시점인 **런타임에 리터럴을 평가해 값을 생성**한다.
리터럴에는 정수 리터럴, 부동소수점 리터럴, 2/8/16진수 리터럴, 문자열 리터럴, 불리언 리터럴 등이 있다.

<br>

## 표현식(expression)

표현식은 값으로 평가될 수 있는 문(statement)이다. 즉, **표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.**

- 표현식은 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다.
- **표현식**과 표현식이 평가된 **값**은 동등한 관계(동치)이다. 따라서 표현식은 값처럼 사용할 수 있다.

```js
// 리터럴 표현식
10;
("Hi");

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum;
person.name;

// 연산자 표현식
1 + 2;

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
add();
person.getName();
```

<br>

## 문(statement)

문(statement)은 **프로그램을 구성하는 기본 단위이자 최소 실행 단위**이다.

- 문의 집합으로 이루어진 것이 프로그램이다.
- 문은 여러 토큰으로 구성된다. 토큰이란 문법적으로 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

<p align="center">
<img src="https://velog.velcdn.com/images/yuuub/post/49a0f3c9-41bc-44ae-a0f6-d97ad4e3aae7/image.png" width="50%" height="50%" >
</p>

<br>

### 문의 종료를 나타내는 세미콜론(;)

세미콜론(;)은 문의 종료를 나타낸다. 따라서 문을 끝낼 때는 세미콜론을 붙여야 한다.
그러나 코드 블록({ … })은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문에 세미콜론을 붙이지 않는다.

- 자바스크립트 엔진이 세미콜론 **자동 삽입 기능**(ASI, automatic semicolon intersection)을 가지고 있기 때문에 알아서 붙여주므로 코드를 작성할 때는 생략해도 좋다.
- 그러나 간혹 세미콜론을 붙이지 않았을 때 ASI가 개발자의 의도와 다르게 해석할 수 있으므로 웬만하면 붙이는 것이 좋을 것 같다.

<br>

### 표현식인 문 vs. 표현식이 아닌 문

- 표현식인 문 = 값으로 평가될 수 **있는** 문
- 표현식이 아닌 문 = 값으로 평가될 수 **없는** 문
- 가장 명료한 방법은 변수에 할당해 보는 것 (표현식이 아닌 문은 값처럼 사용할 수 없기 때문이다.)

```tsx
var foo = var x;  // SyntaxError: Unexpected token var
```

<br>

# 6장. 데이터 타입

## 데이터 타입

데이터 타입이란 **'값의 종류'**를 말한다.
자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 7개의 타입은 원시 타입과 객체 타입으로 나뉜다.

### 원시 타입

- **숫자(number)**
  - 배정밀도 64비트 부동소수점 형식을 따른다.
  - 모든 수를 실수로 처리한다. (따라서 정수끼리 나눠도 실수가 나올 수 있다.)
  - Infinity, -Infinity, NaN(not-a-number)을 표현할 수 있다.
  ```js
  console.log(1 === 1.0); // true
  console.log(1 / 2); // 0.5
  ```
- **문자열(string)**

  - 텍스트 데이터를 나타내는 데 사용한다.
  - 작은따옴표, 큰따옴표, 백틱으로 텍스트를 감싸면 된다.
    ```js
    var string1 = "문자열 1";
    var string2 = "문자열 2";
    var string3 = `문자열 3`;
    ```
  - 템플릿 리터럴(template literal)

    - ES6부터 도입되었으며, 런타임에 일반 문자열로 변환되어 처리된다.
    - 백틱을 사용해 묹열을 표현한다.

    ```js
    var template = `Template literal`;
    console.log(template); // Template literal
    ```

    - 멀티라인 문자열
      - 일반 문자열에서는 줄바꿈을 표현하려면 백슬래시(\)로 시작하는 이스케이프 시퀀스 `\n`를 사용해야 한다.
      - 템플릿 리터럴에서는 보이는 그대로 작성할 수 있다.
      ```js
      console.log(`hello
      I am
      javascript`);
      ```
    - 표현식 삽입

      ```js
      var first = "udong";
      var last = "kim";

      console.log(`My name is ${first} ${last}.`); // My name is udong kim.
      ```

- **불리언(boolean)**
  - 참(true)과 거짓(false)을 나타낸다.
- **undefined**
  - 개발자가 의도적으로 할당하기 위한 값이 아니라, **자바스크립트 엔진이 변수를 초기화할 때** 사용하는 값이다.
- **null**
  - 변수에 값이 없다는 것을 의도적으로 명시하고 싶을 때(의도적 부재, international absence) 사용한다.
  - 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.
- **symbol**
  - ES6에서 추가되었다.
  - 다른 값과 중복되지 않는 유일무이한 값으로, 주로 이름이 충돌할 위험이 없는 **객체의 유일한 프로퍼티 키를 만들기 위해** 사용한다.
    ````js
    // Symbol 함수로 생성
    var key = Symbol('key');
    console.log(typeof key); // symbol
        // 객체의 키로 심볼 사용
        var obj = {};
        obj[key] = 'value';
        ```
    <br>
    ````

### 객체 타입

- 객체
- 함수
- 배열 등

> ECMAScript2020(ES11)에서 새로운 원시값 BigInt가 추가됨으로써 총 8개의 타입을 제공한다.

<br>

## 데이터 타입이 왜 필요할까?

- 값을 저장할 때 확보해야 하는 **메모리 공간의 크기를 결정**하기 위해
  - 자바스크립트 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보한다.
  - ECMAScript 사양에서는 문자열/숫자 외의 데이터 타입의 크기를 명시적으로 규정하고 있지는 않다. 그 외의 타입에 따라 확보되는 메모리 공간의 크기는 자바스크립트 엔진 제조사의 구현에 따라 다를 수 있다.
- 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기를 결정**하기 위해
- 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

<br>

## 자바스크립트는 동적 타입 언어이다.

### 정적 타입 언어

- 변수를 선언할 때 데이터 타입을 선언해야 한다. (명시적 타입 선언)
- 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
- 컴파일 시점에 타입 체크를 수행하고, 이를 통과하지 못했다면 에러를 발생시켜 프로그램의 실행 자체를 막는다.
- ex) C, C++, Java 등
  <br>

### 동적 타입 언어

- 변수를 선언할 때 데이터 타입을 선언하지 않는다.
- 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고, 변수의 타입을 언제든지 자유롭게 변경할 수 있다.
- 동적 타이핑(dynamic typing)
  - 변수는 선언이 아닌 **할당에 의해 타입이 결정**(type inference)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.
- ex) 자바스크립트, 파이썬, PHP 등
- 동적 타입 언어의 단점
  - **유연성(flexibility)는 높지만 신뢰성(reliability)은 떨어진다.**

<br>

위같은 동적 타입 언어의 특징 때문에, 사용할 때는 편하지만 개발자의 의도와 달리 동작하게 되는 경우 예상치 못한 오류를 발생시킬 수 있다.
따라서 다음 주의사항을 지키는 것이 좋다.

- 변수는 꼭 필요한 경우에 한해 제한적으로만 사용한다.
- 변수의 유효 범위(스코프)는 최대한 좁게 만든다.
- 전역 변수는 최대한 사용하지 않는다.
- 변수보다는 상수를 사용한다. (const)
- 변수 네이밍을 명확하게 한다.

<br>

# 7장. 연산자

연산자(operator)는 하나 이상의 표현식을 대상으로 연산을 수행해 하나의 값을 만든다.
연산자에는 산술 연산자, 문자열 연결 연산자, 할당 연산자, 비교 연산자 등이 있다.

### 산술 연산자

피연산자를 대상으로 수학적 계산을 수행하여 숫자 값을 도출하며, 산술 연산이 불가능한 경우 `NaN`을 반환한다.

피연산자의 개수에 따라 이항 산술 연산자, 단항 산술 연산자가 있다.

- 이항 산술 연산자(피연산자 2개)
  - `+`, `-`, `*`, `/`, `%`
- 단항 산술 연산자(피연산자 1개)
  - `++`, `--`
  - `+`, `-`
    - **숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.**
    ```js
    true; // 1
    -true; // -1
    -"Hello"; // NaN
    ```

#### 문자열 연결 연산자

`+` 연산자는 **피연산자 중 하나 이상이 문자열인 경우** 문자열 연결 연산자로 동작한다. (이외에는 산술 연산자로 동작)

```js
// 문자열 연결 연산자
1 + "2"; // '12'

// 산술 연산자
1 + 2; // 3
```

<br>

### 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 따라서 변수 값이 변하는 부수 효과가 존재한다.

```js
var x = 10;
console.log(x); // 10

x += 5;
console.log(x); // 15
```

<br>

### 비교 연산자

좌항과 우항의 피연산자를 비교하여 그 결과를 불리언 값으로 반환한다.
비교 연산자는 if 문 등의 조건식에서 주로 사용한다.

#### 동등 비교(loose equality) 연산자 vs. 일치 비교(strict equality) 연산자

- 동등 비교 연산자: 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다. (값만 비교)
- 일치 비교 연산자: 암묵적 타입 변환을 하지 않고 값을 비교한다. (타입과 값 모두 비교)
  <br>

#### NaN, 0과 비교 연산자를 사용할 때

- NaN은 자신과 일치하지 않는 유일한 값이므로, 숫자가 NaN인지 조사하려면 `Number.isNaN`을 사용한다.

  ```js
  NaN === NaN; // false

  Number.isNaN(NaN); // true
  Number.isNaN(10); // false
  ```

- 양의 0과 음의 0을 구분해야 할 때는 `Object.is` 메서드를 사용한다.
  ```js
  -0 === +0; // true
  Object.is(-0, +0); // false
  ```
- `Object.is` 메소드는 NaN 비교도 정확하게 수행한다.
  ```js
  NaN === NaN; // false
  Object.is(NaN, NaN); // true
  ```

#### 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값을 반환한다. `>`, `<`, `>=`, `<=`가 있다.

```js
5 > 0; // true
5 < 0; // false
5 >= 5; // true
5 <= 5; // true
```

### 삼항 조건 연산자

조건식의 평가 결과에 따라 반환할 값을 결정한다.

```js
조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
```

#### if문과의 차이점

삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만, if문은 값처럼 사용할 수 없다.

<br>

### 논리 연산자

우항과 좌항의 피연산자를 논리 연산한다.

- ||(OR), &&(AND), !(NOT)
  - NOT 연산자는 언제나 불리언 값을 반환한다.
  - OR, AND 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.
    → 평가 결과는 불리언 값이 아닐 수도 있다!

<br>

### typeof 연산자

- 피연산자의 데이터 타입을 문자열로 반환한다.
- `string`, `number`, `boolean`, `undefined`, `symbol`, `object`, `function`
- `null`인지 확인하고 싶다면 `typeof` 연산자 대신 일치 연산자(===)를 사용해야 한다.
  - `typeof null`이 object인 것은 자바스크립트 자체의 버그이다.

```tsx
var foo = null;

typeof foo === null; // false (typeof null은 object)
foo === null; // true
```

이외에도 쉼표 연산자, 그룹 연산자, 지수 연산자 등이 있다.

<br>

# 8장. 제어문

제어문은 조건에 따라 코드 블록을 실행(조건문) 하거나 반복 실행(반복문)할 때 사용한다. 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행되는데, **제어문을 통해 이러한 흐름을 인위적으로 제어할 수 있다.** 제어문의 종류를 알아보자.

<br>

## 블록문

- 자바스크립트는 블록문({})을 **하나의 실행 단위로 취급**한다.
- 단독으로 사용할 수도 있으나, 보통 제어문이나 함수를 정의할 때 사용한다.

<br>

## 조건문

조건문은 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정한다.

### if … else 문

```js
if (조건식) {
  // 조건식이 참인 경우 실행
} else {
  // 조건식이 거짓인 경우 실행
}
```

> 만약 조건식이 불리언 값이 아닌 값으로 평가되면, 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환된다.

<br>

### switch 문

주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.

표현식의 평가 결과와 일치하는 case 문으로 실행 흐름이 이동하지만, 해당 문을 실행한 후 switch 문을 탈출하지 않고 끝까지 실행하기 때문에(풀 스루) `break` 문을 사용해야 한다.

```js
switch (표현식) {
  case 표현식1:
    switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;
  case 표현식2:
    switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;
  default:
    switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
    }
```

<br>

## 반복문

조건식의 평가 결과가 참인 경우 코드 블록을 실행하고, 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다. (조건식이 거짓이 될 때까지 반복)

### for 문

반복 횟수가 **명확**할 때 주로 사용한다.

```js
for (var i = 0; i < 2; i++) {
  console.log(i);
}
// 0
// 1
```

<br>

### while 문

반복 횟수가 **불명확**할 때 주로 사용한다.

```js
let count = 0;

while (true) {
  count++;

  if (count === 3) break;
}
```

<br>

### do … while 문

코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록을 **무조건 한 번은 실행**해야 할 때 사용한다.

```js
var count = 0;

do {
  count++;
} while (count < 3);
```

<br>

### break 문

레이블 문, 반복문, switch 문의 코드를 탈출한다. (이외에는 `SyntaxError`가 발생한다.)

#### 레이블 문

프로그램의 실행 순서를 제어하는 데 사용한다.

```js
foo: {
  console.log(1);
  break foo;
  console.log(2);
}
// 1만 출력됨
```

중첩 for 문의 내부 for 문에서 외부 for 문을 탈출하기 위해 사용할 수 있다. (이때만 쓰는 게 좋다.)

```js
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    // i + j === 3이면 outer라는 식별자가 붙은 레이블 for문을 탈출한다.
    if (i + j === 3) break outer;
  }
}
```

### continue 문

반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. **즉시 다음 반복으로 넘어간다**고 생각하면 편하다.

```js
for (let i = 1; i <= 5; i++) {
  if (i === 3) continue;
  console.log(`The number is ${i}`);
}

// The number is 1
// The number is 2
// The number is 4
// The number is 5
```

<br>

# 9장. 타입 변환과 단축 평가

## 타입 변환

자바스크립트의 모든 값은 [타입](%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85)이 있으며, 동적 타입 언어이기 때문에 타입을 변환할 수 있다.

개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환(explicit coercion), 타입 캐스팅**이라고 하고, 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되는 것을 **암묵적 타입 변환(implicit coercion), 타입 강제 변환**이라고 한다.

> 기존 원시 값을 직접 변경하는 것이 아니라, **기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성**하는 것이다.

<br>

### 암묵적 타입 변환(타입 강제 변환)

#### 문자열 타입으로 변환

- **문자열 연결 연산자** 사용 시 피연산자는 모두 문자열 타입으로 변환된다.

```js
// 숫자 타입
0 +
  "" - // "0"
  0 +
  ""; // "0"
1 +
  "" - // "1"
  1 +
  ""; // "-1"
NaN + ""; // "NaN"
Infinity +
  "" - // "Infinity"
  Infinity +
  ""; // "-Infinity"

// 불리언 타입
true + ""; // "true"
false + ""; // "false"

// null 타입
null + ""; // "null"

// undefined 타입
undefined +
  ""(
    // "undefined"

    // 심벌 타입
    Symbol()
  ) +
  ""(
    // TypeError: Cannot convert a Symbol value to a string

    // 객체 타입
    {}
  ) +
  ""; // "[object Object]"
Math +
  "" ** // "[object Object]"
    [] +
  "" ** // ""**
    [10, 20] +
  "" ** // "10,20"**
    function () {} +
  "" ** // "function(){}"**
    Array +
  ""; // "function Array() { [native code] }"**
```

<br>

#### 숫자 타입으로 변환

- 산술 연산자를 사용할 때
  - 산술 연산자의 피연산자는 모두 숫자 타입으로 변환된다.
  - 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 표현식이 NaN으로 평가된다.
- 비교 연산자를 사용할 때
  - `+` 단항 연산자를 사용할 때
  ```js
  // 문자열 타입
  +"" + // 0
    "0" + // 0
    "1" + // 1
    "string" + // NaN
    // 불리언 타입
    true + // 1
    false + // 0
    // null 타입
    null + // 0
    // undefined 타입
    undefined + // NaN
    // 심벌 타입
    Symbol() + // TypeError: Cannot convert a Symbol value to a number
    // 객체 타입
    {} + // NaN
    [] + // 0
    [10, 20] + // NaN
    function () {}; // NaN
  ```
- 빈 문자열(’’), 빈 배열([]), null, false → 0

<br>

#### 불리언 타입으로 변환

- 조건식의 평가 결과는 불리언 타입으로 변환된다.
- 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다.
- Falsy 값
  - `false`
  - `undefined`
  - `null`
  - `0`, `-0`
  - `NaN`
  - `‘’` (빈 문자열)
  - 나머지는 모두 Truthy 값이다!

<br>

### 명시적 타입 변환

#### 문자열 타입으로 변환하는 방법

1. `String` 생성자 함수를 `new` 없이 호출

```js
String(1); // "1"
String(NaN); // "NaN"
String(true); // "true"
```

2. `Object.prototype.toString` 메서드를 사용하는 방법

```js
(1).toString(); // "1"
NaN.toString(); // "NaN"
true.toString(); // "true"
```

3. 문자열 연결 연산자

```js
1 + ""; // "1"
NaN + ""; // "NaN"
true + ""; // "true"
```

<br>

#### 숫자 타입으로 변환하는 방법

1. `Number` 생성자 함수를 `new` 없이 호출

```js
Number("0"); // 0
Number(true); // 1
Number(false); // 0
```

2. `parseInt`, `parseFloat` 함수 사용(문자열→숫자)

```js
parseInt("0"); // 0
parseIFloat("10.53"); // 10.53
```

3. `+` 단항 산술 연산자 이용

```js
+"0"; // 0
+"-1"; // 1
+"10.53"; // 10.53
+true; // 1
+false; // 0
```

4. `*` 산술 연산자 이용

```js
"0" * 1; // 0
"-1" * 1; // -1
"10.53" * 1; // 10.53
true * 1; // 1
false * 1; // 0
```

<br>

#### 불리언 타입으로 변환하는 방법

1. `Boolean` 생성자 함수를 `new` 없이 호출

```js
Boolean("x"); // true
Boolean(""); // false
Boolean("false"); // true (빈 문자열이 아니므로 true)

Boolean(0); // false
Boolean(true); // true
Boolean(NaN); // false
Boolean(Infinity); // true

Boolean(null); // false
Boolean(undefined); // false

Boolean({}); // true
Boolean([]); // true
```

2. `!` 부정 논리 연산자 두 번 사용

```js
!!"x"; // true (!'x' -> false, !!'x' -> true)
!!""; // false
!!"false"; // true

!!0; // false
!!1; // true
!!NaN; // false
!!Infinity; // true

!!null; // false
!!undefined; // false

!!{}; // true
!![]; // true
```

<br>

## 단축 평가

- **표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것**
- 논리 연산자를 사용한 단축 평가
  ```js
  "Cat" && "Dog"; // "Dog"
  ```
  - 논리곱(`&&`) 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 즉, 두 번째 피연산자까지 평가해야 위 표현식을 평가할 수 있다.
  - 논리 연산의 결과를 결정하는 두 번째 피연산자, 즉 문자열 ‘Dog’를 그대로 반환한다.
  ```js
  "Cat" || "Dog"; // 'Cat'
  ```
  - 논리합(`||`) 연산자는 두 개의 피연산자 중 하나만 `true`로 평가되어도 `true`를 반환한다.
  - 첫 번째 피연산자(’Cat’)는 `true`로 평가되는데, 이때 두 번째 두 번째 피연산자(’Dog’)까지 평가해보지 않아도 위 표현식을 평가할 수 있다.
  - 논리 연산의 결과를 결정한 첫 번째 피연산자, 즉 문자열 ‘Cat’을 그대로 반환한다.
    | 단축 평가 표현식 | 평가 결과 |
    | ----------------- | --------- | -------- | -------- |
    | true | | anything | true |
    | false | | anything | anything |
    | true && anything | anything |
    | false && anything | false |
- 단축 평가로 if 문을 대체할 수 있다.

  - 어떤 조건이 Truthy 값일 때 무언가를 해야 한다면 → `&&`

    ```js
    // if 문을 사용한 버전
    var done = true;
    var message = "";
    if (done) message = "완료";

    // 단축 평가
    message = done && "완료";
    ```

  - 어떤 조건이 Falsy 값일 때 무언가를 해야 한다면 → `||`

    ```js
    // if 문을 사용한 버전
    var done = false;
    var message = "";
    if (done) message = "미완료";

    // 단축 평가
    message = done || message;
    ```

<br>

### 단축 평가가 유용한 경우

- 객체를 가리키기를 기대하는 변수가 `null` 또는 `undefined`가 아닌지 확인하고 프로퍼티를 참조할 때
  ```js
  var elem = null;
  // elem이 있다면 elem.value 할당, 없다면 elem이 할당됨
  var value = elem && elem.value;
  ```
- 함수 매개변수에 기본값을 설정할 때

  ```js
  function getStringLength(str) {
    str = str || "";
    return str.length;
  }

  // ES6
  function getStringLength(str = "") {
    return str.length;
  }
  ```

<br>

### 옵셔널 체이닝 연산자 `?.`

- ES11(ECMAScript2020)에서 도입되었다.
- 좌항의 피연산자가 `null` 또는 `undefined`인 경우 `undefined`를 반환하고, 그렇지 않으면 우항의 참조를 이어간다.
  ```js
  var elem = null;
  var value = elem?.value;
  console.log(value); // undefined
  ```
- 논리 연산자 `&&`는 좌항 피연산자가 Falsy 값인 경우 좌항 피연산자를 그대로 반환한다. 하지만 옵셔널 체이닝 연산자는 좌항 피연산자가 Falsy 값이라도 `null` 또는 `undefined`가 아니면 우항의 프로퍼티 참조를 이어간다.
  ```js
  var str = "";
  var length = str && str.length;
  console.log(length); // ''
  ```
  ```js
  var str = "";
  var length = str?.length;
  console.log(length); // 0
  ```

<br>

### null 병합 연산자 `??`

- ES11(ECMAScript2020)에서 도입되었다.
- 좌항의 피연산자가 `null` 또는 `undefined`인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
- 변수에 기본값을 설정할 때 유용하다.
  ```js
  var foo = null ?? "default string";
  ```
- 논리 연산자 `||` 와의 차이점
  ```js
  // 만약 0이나 ''도 기본값으로서 유효하다면 예기치 않은 동작이 발생할 수 있다.
  var foo = "" || "default string";
  console.log(foo); // "default strig"
  ```
  ```js
  var foo = "" ?? "default string";
  console.log(foo); // ""
  ```
