# ✍️ 공부한 내용 정리

## 10장 객체 리터럴

### 💡 객체

자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 '모든 것'이 객체입니다. 원시 값을 제외한 나머지 값(함수, 배열, 정규표현식 등)은 모두 객체입니다.

원시 타입은 단 하나의 값만 나타내지만 개체 타입은 다양한 타입의 값(원시 값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조입니다.

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성됩니다. 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있는데요, 프로퍼티 값이 함수일 경우에는 일반 함수와 구분하기 위해 메서드라고 부릅니다.

프로퍼티와 메서드의 역할은 다음과 같습니다.

- **프로퍼티**: 객체의 상태를 나타내는 값
- **메서드**: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작

이제 프로퍼티와 메서드에 대해 알아보겠습니다.

### 💡 프로퍼티

> **객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성됩니다.**

```js
var person = {
  // 프로퍼티 키는 name, 프로퍼티 값은 'Lee'
  name: "Lee",
  // 프로퍼티 키는 age, 프로퍼티 값은 20
  age: 20,
};
```

프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 다음과 같습니다.

- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 깂

### 💡 메서드

함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있습니다.

프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부릅니다. 즉, 메서드는 객체에 묶여 있는 함수를 의미합니다.

```js
var circle = {
  radius: 5, // <- 프로퍼티

  getDiameter: function () {
    // <- 메서드
    return 2 * this.radius; // this는 circle을 가리킴
  },
};

console.log(circle.getDiameter()); // 10
```

### 💡 프로퍼티 접근

프로퍼티에 접근하는 방법은 두 가지입니다.

- 마침표 프로퍼티 접근 연산자(.)를 사용하는 **마침표 표기법**
- 대괄호 프로퍼티 접근 연산자([...])를 사용하는 **대괄호 표기법**

```js
var person = {
  name: "Lee",
};

// 마침표 표기법에 의한 프로퍼티 접근
console.log(persone.name); // Lee

// 대괄호 표기법에 의한 프로퍼티 접근
console.log(person["name"]); // Lee
```

**객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환합니다.** 이때 ReferenceError가 발생하지 않는 데 주의해야 합니다.

```js
var person = {
  name: "Lee",
};

console.log(persone.age); // undefined
```

### 💡 프로퍼티 동작

#### ⏺️ 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됩니다.

```js
var person = {
  name: "Lee",
};

// person 객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신됨
person.name = "Kim";

console.log(person); // {name: "Kim"}
```

#### ⏺️ 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당됩니다.

```js
var person = {
  name: "Lee",
};

// person 객체에는 age 프로퍼티가 존재하지 않음
// 따라서 person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당됨
person.age = 20;

console.log(person); // {name: "Lee",age: 20}
```

#### ⏺️ 프로퍼티 삭제

**delete** 연산자는 객체의 프로퍼티를 삭제합니다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 합니다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러 없이 무시됩니다.

```js
var person = {
  name: "Lee",
};

// 프로퍼티 동적 생성
person.age = 20;

// person 객체에 age 프로퍼티가 존재함
// 따라서 delete 연산자로 age 프로퍼티를 삭제할 수 있음
delete person.age;

// person 객체에 address 프로퍼티가 존재하지 않음
// 따라서 delete 연산자로 address 프로퍼티를 삭제할 수 없음. 이때 에러가 발생하지 않음
delete person.address;

console.log(person); // {name: "Lee"}
```

### 💡 ES6에서의 객체

#### ⏺️ 프로퍼티 축약 표현

객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성됩니다. 프로퍼티의 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있습니다.

```js
// ES5
var x = 1,
  y = 2;

var obj = {
  x: x,
  y: y,
};

console.log(obj); // {x: 1, y: 2}
```

ES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있습니다. 이때 프로퍼티 키는 변수 이름으로 자동 생성됩니다.

```js
// ES6
let x = 1,
  y = 2;

// 프로퍼티 축약 표현
const obj = { x, y };

console.log(obj); // {x: 1, y: 2}
```

#### ⏺️ 메서드 축약 표현

ES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당합니다.

```js
// ES5
var obj = {
  name: "Lee",
  sayHi: function () {
    console.log("Hi! " + this.name);
  },
};

obj.sayHi(); // Hi! Lee
```

ES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있습니다.

```js
// ES6
const obj = {
  name: "Lee",
  sayHi() {
    console.log("Hi! " + this.name);
  },
};

obj.sayHi(); // Hi! Lee
```

ES6의 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작합니다. 이에 대한 내용은 이후에 살펴보겠습니다.

<br/>

### 📑 10장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- 프로퍼티와 메서드가 무엇인지
- 프로퍼티 접근 및 동적 생성과 삭제
- ES6에서 추가된 객체 리터럴의 확장 기능

<br/>

## 11장 원시 값과 객체의 비교

자바스크립트가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, 심벌, 객체 타입)은 크게 **원시 타입**과 **객체 타입**으로 구분할 수 있습니다. 원시 타입과 객체 타입은 크게 세 가지 측면에서 다릅니다.

- **원시 타입의 값, 즉 원시 값은 변경 불가능한 값**입니다. 이에 비래 **객체(참조) 타입의 값, 즉 객체는 변경 가능한 값**입니다.
- **원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장**됩니다. 이에 비해 **객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장**됩니다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 **원시 값이 복사되어 전달**됩니다. 이를 **값에 의한 전달**이라고 합니다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어 전달**됩니다. 이를 **참조에 의한 전달**이라고 합니다.

### 💡 원시 값

#### ⏺️ 변경 불가능한 값

> **원시 타입의 값, 즉 원시 값은 변경 불가능한 값**입니다.

변수와 값은 구분해서 생각해야 합니다. 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고, 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 말합니다. **변경 불가능하다는 것은 변수가 아니라 값에 대한 진술입니다.**

변수는 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있습니다. 변수의 상대 개념인 상수는 재할당이 금지된 변수를 말합니다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있습니다. 단, 변수는 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있지만 상수는 단 한 번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없습니다. 상수는 재할당이 금지된 변수일 뿐입니다.

```js
// const 키워드를 사용해 선언한 변수는 재할다이 금지됨. 상수는 재할당이 금지된 변수일 뿐임
const o = {};

// const 키워드를 사용해 선언한 변수에 할당한 원시 값(상수)는 변경할 수 없음
// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있음
o.a = 1;

console.log(o); // {a: 1}
```

원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킵니다. 이때 변수가 참조하던 메모리 공간의 주소가 바뀝니다. 값의 이러한 특성을 **불변성**이라고 합니다.

**불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없습니다.**

자바스크립트의 문자열의 경우 원시 타입이며, 변경 불가능합니다. 이것은 문자열이 생성된 이후에는 변경할 수 없음을 의미합니다.

```js
var str = "string";

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있음
// 하지만 문자열은 원시 값이므로 변경할 수 없음. 이때 에러가 발생하지 않음.
str[0] = "S";

console.log(str); // string
```

위 예시처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않습니다. 문자열은 변경 불가능한 값이기 때문입니다. 이처럼 한번 생성된 문자열은 읽기 전용 값으로서 변경할 수 없습니다. 그러나 변수에 새로운 문자열을 재할당하는 것은 가능합니다. 이는 기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이기 때문입니다.

#### ⏺️ 값에 의한 전달

아래 예시를 통해 설명해보겠습니다.

```js
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당됨
var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향을 주지 않음
score = 100;

console.log(score, copy); // 100 80
console.log(score === copy); // false
```

`var copy = score`에서 처럼 변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달됩니다. 이를 **값에 의한 전달**이라고 합니다. 이때 score 변수와 copy 변수는 숫자 값 80을 갖는다는 점에서는 동일합니다. 하지만 **score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값입니다.** 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않습니다.

`값에 의한 전달`이라는 용어는 자바스크립트를 위한 용어가 아니므로 사실 오해가 있을 수도 있습니다. **엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문입니다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문입니다.**

중요한 것은 **결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다**는 것입니다.

### 💡 객체

#### ⏺️ 변경 가능한 값

**객체(참조) 타입의 값, 즉 객체는 변경 가능한 값**입니다. 먼저 변수에 객체를 할당하면 어떤 일이 일어나는지 살펴보겠습니다.

```js
var person = {
  name: "Lee",
};
```

원시 값을 할당한 변수가 원시 값 자체를 값으로 갖는 것과 달리 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값**에 접근할 수 있습니다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체 입니다.

일반적으로 원시 값을 할당한 변수의 경우 '변수는 O값을 갖는다' 또는 '변수의 값은 O다'라고 표현합니다. 하지만 객체를 할당한 변수의 경우 '변수는 객체를 참조하고 있다' 또는 '변수는 객체를 가리키고 있다'라고 표현합니다.

**원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없습니다. 하지만 객체는 변경 가능한 값입니다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있습니다. 즉, 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있습니다.**

```js
var person = {
  name: "Lee",
};

// 프로퍼티 값 갱신
person.name = "Kim";

// 프로퍼티 동적 생성
person.address = "Seoul";

console.log(person); // {name: "Kim", address: "Seoul"}
```

객체는 이러한 구조에 따른 부작용이 있는데, 그것은 원시 값과는 다르게 **여러 개의 식별자가 하나의 객체를 공유할 수 있다**는 것입니다.

#### ⏺️ 참조에 의한 전달

여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무엇을 의미하는지, 이로 인해 어떤 부작용이 발생하는지 알아보겠습니다.

```js
var person = {
  name: "Lee",
};

// 참조 값을 복사(얕은 복사)
var copy = person;
```

객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 **참조 값**이 복사되어 전달됩니다. 이를 **참조에 의한 전달**이라고 합니다.

참조에 의한 전달이라는 것은 원본 person과 사본 copy에 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖는다는 것입니다. 즉, 원본 person과 사본 copy 모두 동일한 객체를 가리킵니다. 이것은 **두 개의 식별자가 하나의 객체를 공유**한다는 것을 의미합니다. 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받습니다.

```js
var person = {
  name: "Lee",
};

// 참조 값을 복사(얕은 복사). copy와 person은 동일한 참조 값을 갖음
var copy = person;

// copy와 person은 동일한 객체를 참조
console.log(copy === person); // true

// copy를 통해 객체를 변경
copy.name = "Kim";

// person을 통해 객체를 변경
person.address = "Seoul";

// copy와 person은 동일한 객체를 가리킴
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받음
console.log(person); // {name: "Lee", address: "Seoul"}
console.log(copy); // {name: "Lee", address: "Seoul"}
```

결국 **`값에 의한 전달`과 `참조에 의한 전달`은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일합니다.** 다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐입니다. 따라서 **자바스크립트에는 `참조에 의한 전달`은 존재하지 않고 `값에 의한 전달`만이 존재한다고 말할 수 있습니다.**

<br/>

### 📑 11장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- 원시 값을 갖는 변수에 재할당을 하는 과정
- 객체를 참조하는 변수를 다른 변수에 복사하는 과정

<br/>

## 12장 함수

### 💡 함수란?

프로그래밍 언어의 **함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것입니다.**

프로그래밍 언어의 함수도 수학의 함수와 마찬가지로 입력을 받아서 출력을 내보냅니다. 이때 함수 내부로 입력을 전달받는 변수를 **매개변수**, 입력을 **인수**, 출력을 **반환값**이라고 합니다. 또한 함수는 값이며, 여러 개가 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있습니다.

함수는 **함수 정의**를 통해 생성합니다. 다음은 함수 선언문을 통해 함수를 정의한 예시입니다.

```js
// 함수 정의
function add(x, y) {
  return x + y;
}
```

함수 정의만으로 함수가 실행되는 것은 아닙니다. 함수의 실행을 명시적으로 지시해야 합니다. 이를 **함수 호출**이라고 합니다. 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되어 실행 결과, 즉 반환값을 반환합니다.

```js
// 함수 호출
var result = add(2, 5);

// 함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환함
console.log(result);
```

### 💡 함수 정의

#### ⏺️ 함수 선언문

함수 선언문을 사용해 함수를 정의하는 방식은 다음과 같습니다.

```js
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 참조
// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력함
console.dir(add); // f add(x, y)

console.log(add(2, 5)); // 7
```

함수 선언문은 함수 리터럴과 형태가 동일합니다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 **함수 선언문은 함수 이름을 생략할 수 없습니다.**

```js
// 함수 선언문은 함수 이름을 생략할 수 없음
function (x, y){
  return x + y;
}
// SyntaxError: Function statements require a function name
```

**함수 선언문은 표현식 아닌 문입니다.** 따라서 변수에 할당할 수 없습니다. 하지만 다음 예시를 보면 함수 선언문이 변수에 할당되는 것처럼 보입니다.

```js
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없음
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보임
var add = function add(x, y) {
  return x + y;
};

// 함수 호출
console.log(add(2, 5)); // 7
```

이렇게 동작하는 이유는 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문입니다. 함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일합니다. 이는 함수 이름이 있는 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다는 의미입니다.

자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성합니다. 이때 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름과는 별도로 생성된 함수 객체를 가리키는 식별자가 필요합니다. 함수 객체를 가리키는 식별자가 없으면 생성된 함수 객체를 참조할 수 없으므로 호출할 수도 없습니다. 따라서 **자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당합니다.**

```js
function foo() {
  console.log("foo");
}

foo(); // foo
```

**함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출합니다.**

#### ⏺️ 함수 표현식

값의 성질을 갖는 객체를 **일급 객체**라고 하는데, **자바스크립트의 함수는 일급 객체입니다.** 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미입니다.

함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있습니다. 이러한 함수 정의 방식을 함수 표현식이라고 합니다.

```js
// 함수 표현식
var add = function (x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

함수 리터럴의 함수 이름은 생략할 수 있습니다. 이러한 함수를 익명 함수라 합니다. 앞에서 살펴봤듯이 함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 합니다. 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 함수를 호출할 수 없습니다.

```js
// 기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 ReferenceError가 발생함
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자임
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```

#### ⏺️ 화살표 함수

ES6에서 도입된 화살표 함수는 `function` 키워드 대신 `화살표(=>)`를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있습니다. 화살표 함수는 항상 익명 함수로 정의합니다.

```js
// 화살표 함수
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

화살표 함수는 기존의 함수 선언문 또는 함수 표현식을 완전히 대체하기 위해 디자인된 것은 아닙니다. 화살표 함수는 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화되어 있습니다. 화살표 함수에 대해서는 이후 자세히 살펴보겠습니다.

### 💡 함수 생성 시점과 호이스팅

다음 예시를 살펴보겠습니다.

```js
// 험수 참조
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

위 예시와 같이 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있습니다. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없습니다. 이는 **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문입니다.**

모든 선언문이 그렇듯 함수 선언문도 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행됩니다. 즉, 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태입니다. 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있습니다. 이처럼 **함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라고 합니다.**

함수 호이스팅과 변수 호이스팅은 미묘한 차이가 있습니다. var 키워드를 사용한 변수 선언문과 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일합니다. 하지만 var 키워드를 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가되는 반면 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능합니다.

함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문입니다. 따라서 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작합니다. 변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만 **변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됩니다.**

따라서 **함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생합니다.**

함수 표현식 이전에 함수를 참조하면 undefined로 평가됩니다. 따라서 이때 함수를 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러가 발생합니다. 따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 합니다.

함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하므로 함수 선언문 대신 함수 표현식을 사용하는 것이 권장됩니다.

### 💡 참조에 의한 전달과 외부 상태의 변경

매개변수는 함수 몸체 내부에서 변수와 동일하게 취급되므로 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 원시 값과 객체와 같이 따릅니다. 다음 예시를 보겠습니다.

```js
// 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달받음
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = "Kim";
}

// 외부 상태
var num = 100;
var person = { name: "Lee" };

console.log(num); // 100
console.log(person); // {name: "Lee"}

// 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달됨
changeVal(num, person);

// 원시 값은 원본이 훼손되지 않음
console.log(num); // 100

// 객체는 원본이 훼손됨
console.log(person); // {name: "Kim"}
```

changeVal 함수를 살펴보겠습니다. 매개변수 primitive는 원시 타입 인수를 전달받았는데, 원시 값은 변경 불가능한 값이므로 재할당을 통해 할당된 원시 값을 새로운 원시 값으로 교체합니다. 객체 타입 인수를 전달받은 매개변수 obj의 경우, 객체는 변경 가능한 값이므로 재할당 없이 직접 할당된 객체를 변경했습니다.

이때 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경해도 원본은 훼손되지 않지만, 객체 타입 인수는 참조 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손됩니다.

### 💡 다양한 함수의 형태

#### ⏺️ 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 합니다. 즉시 실행 함수는 단 한 번만 호출되며 다시 호출할 수 없습니다.

```js
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a * b;
})();
```

즉시 실행 함수는 반드시 `그룹 연산자(...)`로 감싸야 합니다. 그렇지 않으면 다음과 같이 에러가 발생합니다.

```js
function(){  // SyntaxError: Function statements require a function name
  // ...
}();
```

그룹 연산자의 피연산자는 값으로 평가되므로 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 됩니다. 즉, 그룹 연산자로 함수를 묶는 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서입니다.

#### ⏺️ 콜백 함수

> **함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 합니다.**

다음은 콜백 함수와 고차 함수의 예시입니다.

```js
// 외부에서 전달받은 f를 n만큼 반복 호출함
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); // i를 전달하면서 f를 호출
  }
}

var logAll = function (i) {
  console.log(i);
};

// 반복 호출할 함수를 인수로 전달함
repeat(5, logAll); // 0 1 2 3 4

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 반복 호출할 함수를 인수로 전달함
repeat(5, logOdds); // 1 3
```

콜백 함수는 함수 외부에서 고차 함수 내부로 콜백 함수를 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있습니다. 즉, **고차 함수는 콜백 함수를 자신의 일부분으로 합성합니다.**

**고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출합니다.** 다시 말해, **콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있습니다.** 따라서 고차 함수에 콜백 함수를 전달할 때 콜백 함수를 호출하지 않고 함수 자체를 전달해야 합니다.

#### ⏺️ 순수 함수와 비순수 함수

함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수라고 합니다.

다음은 순수 함수의 예시입니다. 순수 함수는 함수의 외부 상태를 변경하지 않습니다.

```js
var count = 0; // 현재 카운트를 나타내는 상태

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환함
function increase(n) {
  return n++;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```

다음은 비순수 함수의 예시입니다. 비순수 함수는 함수의 외부 상태를 변경하는 부수 효과가 있습니다.

```js
var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변경됨

// 비순수 함수
function increase(count) {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경함
}

// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워짐
increase();
console.log(count); // 1

increase();
console.log(count); // 2
```

함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워집니다. 따라서 함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋습니다. 비순수 함수를 최대한 줄이는 것은 부수 효과를 최대한 억제하는 것과 같습니다.

### 📑 12장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- 함수 정의 방법
- 함수 호이스팅
- 콜백 함수와 순수 함수

<br/>

## 13장 스코프

### 💡 스코프

모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정됩니다. 이를 스코프라고 합니다. 즉, 스코프는 식별자가 유효한 범위를 말합니다.

다음 예시를 살펴보겠습니다.

```js
var x = "global";

function foo() {
  var x = "local";
  console.log(x); // ①
}

foo();

console.log(x); // ②
```

자바스크립트 엔진은 이름이 같은 두 개의 변수 x 중에서 어떤 변수를 ①과 ②에서 참조할지 결정해야합니다. 이를 **식별자 결정**이라고 합니다. 자바스크립트는 스코프를 통해 어떤 변수를 참조해야 할 것인지 결정합니다. 따라서 스코프란 자바스크립트 엔진이 **식별자를 검색할 때 사용하는 규칙**이라고도 할 수 있습니다.

### 💡 스코프의 종류

코드는 전역과 지역으로 구분할 수 있습니다.

전역이란 코드의 가장 바깥 영역을 말합니다. 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 됩니다. **전역 변수는 어디서든지 참조할 수 있습니다.**

지역이란 함수 몸체 내부를 말합니다. 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 됩니다. 지역 변수는 자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조를 할 수 있습니다. **다시 말해, 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효합니다.**

### 💡 스코프 체인

함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있습니다. 이는 **스코프가 함수의 중첩에 의해 계층적 구조를 갖는다**는 것을 의미합니다. 다시 말해, 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖습니다. 이때 외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라고 합니다.

모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프입니다. 이렇게 스코프가 계층적으로 연결된 것을 **스코프 체인**이라고 합니다.

**변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프렝서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색합니다.** 이를 통해 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있습니다.

자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색합니다. **상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다는 것을 의미합니다.**

### 💡 함수 레벨 스코프

**지역 스코프는 코드 블록이 아닌 함수에 의해서만 생성됩니다.**

대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록(if, for, while 등)이 지역 스코프를 만듭니다. 이러한 특성을 **블록 레벨 스코프**라고 합니다. 하지만 **var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정**합니다. 이러한 특성을 **함수 레벨 스코프**라고 합니다.

### 💡 렉시컬 스코프

렉시컬 스코프를 이애하기 위한 좋은 예시가 있습니다.

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

위 예시의 실행 결과는 bar 함수의 상위 스코프가 무엇인지에 따라 결정됩니다. 두 가지 경우의 수가 있습니다.

- 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정
- 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정

첫 번째 방식을 동적 스코프라고 합니다. 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없습니다. 따라서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라고 부릅니다.

두 번째 방식은 렉시컬 스코프 또는 정적 스코프라고 합니다. 동적 스코프 방식처럼 상위 스코프가 동적으로 변하지 않고 함수 저의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라고 부릅니다.

**자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정합니다. 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않습니다. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프입니다.**

**이처럼 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정됩니다. 함수 정의가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억합니다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문입니다.**

따라서 위 예시의 결과는 다음과 같습니다.

```js
foo(); // 10
bar(); // 1
```

<br/>

### 📑 13장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- 스코프 체인이 무엇인지
- 렉시컬 스코프가 무엇인지

<br/>

## 14장 전역 변수의 문제점

### 💡 지역 변수의 생명 주기

지역 변수의 생명 주기는 함수의 생명 주기와 일치합니다. 다음 예시를 보겠습니다.

```js
var x = "global";

function foo() {
  console.log(x); // ①
  var x = "local";
}

foo();
console.log(x); // global
```

foo 함수 내부에서의 출력 값은 무엇일까요? foo 함수 내부에서 선언된 지역 변수 x는 ①의 시점에 이미 선언되었고 undefined로 초기화되어 있습니다. 따라서 전역 변수 x를 참조하는 것이 아니라 지역 변수 x를 참조해 값을 출력합니다. 즉, 지역 변수는 함수 전체에서 유효합니다.

이처럼 **호이스팅을 스코프를 단위로 동작합니다.** 지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작합니다. 따라서 지역 변수는 함수 전체에서 유효합니다. 즉, **호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말합니다.**

<br/>

### 📑 14장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- 스코프와 변수 호이스팅

<br/>

## 15장 let, const 키워드와 블록 레벨 스코프

### 💡 var 키워드로 선언한 변수의 문제점

ES5까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었습니다.

var 키워드로 선언한 변수는 여러 특징이자 단점이 있습니다.

- 변수 중복 선언 허용
- 함수 레벨 스코프
- 변수 호이스팅

이러한 var 키워드의 단점을 보완하기 위해 ES6에서 새로운 변수 선언 키워드인 let과 const를 도입했습니다.

### 💡 var vs. let vs. const

먼저 let과 const의 공통점을 알아보겠습니다.

#### ⏺️ 블록 레벨 스코프

var 키워드로 선언된 변수는 함수 레벨 스코프를 갖습니다. 즉, 함수 레벨 이외에서 선언될 경우 전역 변수로 사용됩니다. 하지만 let과 const 키워드로 선언된 변수는 블록 레벨 스코프를 갖습니다. 다음 예시를 보겠습니다.

```js
var x = 1; // 전역으로 선언된 변수 x
let y = 10; // 전역으로 선언된 변수 y
const z = 100; // 전역으로 선언된 상수 z

if (true) {
  var x = 0; // 블록 내에서 선언되었지만 전역으로 사용되는 변수 x
  let y = 0; // 블록 내에서 선언된 지역 변수 y
  const z = 0; // 블록 내에서 선언된 지역 상수 z
}

console.log(x); // 0
console.log(y); // 10
console.log(z); // 100
```

위 예시에서 볼 수 있듯이 let과 const 키워드로 선언된 변수는 블록 레벨 스코프에서는 지역 변수로 사용되어 지역 스코프 안에서만 참조됩니다. 이는 var 키워드로 선언된 변수보다 안정성이 있습니다.

#### ⏺️ 변수 호이스팅

var 키워드로 선언한 변수와 달리 let, const로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작합니다. 다음 예시를 보겠습니다.

```js
console.log(foo); // ReferenceError: foo is not defined
let foo;

console.log(bar); // ReferenceError: bar is not defined
const bar = 123;
```

이처럼 let과 const 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러가 발생합니다. 이는 두 키워드가 var 키워드와는 다르게 선언 단계와 초기화 단계가 진행되기 때문입니다.

let, const 키워드의 경우를 살펴보겠습니다. **let, const 키워드로 선언한 변수는 '선언 단계'와 '초기화 단계'가 분리되어 진행됩니다.** 즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행됩니다. var 키워드의 경우에는 선언 단계와 동시에 초기화 단계가 실행되어 암묵적으로 undefined로 변수를 초기화합니다.

만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러가 발생합니다. let, const 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없습니다. 스코프의 시작 지점부터 초기화 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대라고 부릅니다. 다만 const 키워드는 상수를 선언하기 위해 사용되기 때문에 **const 키워드로 선언한 변수는 선언과 동시에 초기화해야 합니다.**

```js
// 런타임 이전에 선언 단계가 실행됨. 아직 변수가 초기화 되지 않음
// 초기화 이전의 일시적 사각지대에서는 변수를 참조할 수 없음
console.log(foo); // ReferenceError: foo is not defined
console.log(bar); // ReferenceError: bar is not defined

let foo; // 변수 선언문에서 초기화 단계가 실행됨
console.log(foo); // undefined

foo = 10;
console.log(foo); // 10

const bar = 123; // const 키워드는 상수를 선언하므로 선언과 동시에 초기화함
console.log(bar); // 123
```

결국 let, const 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않은 것처럼 보이지만 그렇지 않습니다.

```js
let foo = 1; // 전역 변수
const bar = 123; // 전역 변수

{
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  console.log(bar); // ReferenceError: Cannot access 'bar' before initialization
  let foo = 2; // 지역 변수
  const bar = 0; // 지역 변수
}
```

만약 호이스팅이 발생하지 않았다면 에러가 발생하지 않고 전역 변수인 foo와 bar을 참조하여 출력했을 것입니다. 하지만 블록 레벨 스코프 안에서 변수 호이스팅이 발생하여 지역 변수 foo와 bar가 스코프 상단으로 끌어올려졌고, 초기화 단계까지 참조가 불가능하기 때문에 참조 에러가 발생하게 되었습니다.

#### ⏺️ let과 const의 차이점

다음으로 let과 const의 차이점을 알아보겠습니다. 앞서 말했듯 const 키워드는 상수를 선언하기 위해 사용되기 때문에 const 키워드로 선언한 변수는 재할당이 금지됩니다. 하지만 const 키워드로 선언된 변수에 객체를 할당한 경우에는 값을 변경할 수 있습니다.

```js
const foo = 1;
foo = 2; // TypeError: Assignment to constant variable

const person = {
  name: "Lee",
};

// 객체는 변경 가능한 값입니다. 따라서 재할당 없이 변경이 가능합니다.
person.name = "Kim";

console.log(person); // {name: 'Kim'}
```

<br/>

### 📑 15장 키워드

아래 내용들을 이해했는지 스스로 확인해봅시다!

- var 키워드의 단점
- var과 let, const의 차이
- var, let과 const의 차이
