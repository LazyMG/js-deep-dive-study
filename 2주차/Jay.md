# 불변성과 가변성
원시 타입 데이터는 콜 스택(실행 컨텍스트에서 확보한 환경 레코드)에 값을 직접 저장하고, 참조 타입 데이터(객체)는 힙 메모리 영역에 값을 저장하고 콜 스택엔 데이터가 저장된 힙 메모리 주소를 저장한다. 말 그대로 데이터를 '참조'해서 저장하는 것이다.

원시 타입은 값을 직접 저장하고, 한번 저장된 값은 변경 불가능하다. 예를 들어, `let str = 'abc'` 처럼 선언-할당한 값에 인덱스로 접근해서 값을 변경하려고 하면(`str[1] = 'd'`) 값 변경이 안된다(에러가 나진 않는다). 만약에 변수에 다른 값을 재할당하면 그건 값의 불변성이 깨진 게 아니라, 콜 스택에 새로운 메모리 공간을 확보하고 값을 다시 저장한 것이다. 아예 새로운 메모리에 값을 다시 저장하고 참조를 변경한 것이기 때문에 최초에 저장된 값의 불변성은 깨지지 않는다.

참조 타입은 참조로 접근해서 힙에 저장된 데이터를 변경할 수 있다. 콜 스택 기준으로 저장된 값(힙 메모리 주소)은 고정인 상태로 값이 변경되기 때문에 '가변적이다'라고 부른다. 하지만, 이는 콜 스택에 저장된 값 기준의 얘기이지, 힙에 저장된 원시 타입 데이터는 값을 수정할 때마다 저장된 공간이 변경된다. 즉, 객체의 각 프로퍼티가 참조하는 값은 원시 타입일 경우 불변이 유지되고, 참조 타입인 데이터 기준으로는 가변한다.


# 객체의 프로퍼티
프로퍼티는 객체 내부에 존재하는 식별자다. 값을 저장하는 경우와 함수를 저장하는 경우로 구분되는데, 함수를 저장하는 프로퍼티를 별도로 '메서드'라고 부른다. 

객체의 특성 상 프로퍼티와 메서드로 특정한 구분을 만들고, 특정 분류가 가지는 속성과 동작을 프로퍼티-메서드로 표현한다. 객체 간 가진 속성의 독립성을 유지하면서, 객체의 고유한 속성들을 바탕으로 하나의 프로그램을 완성해가는 개발 패러다임을 '객체 지향 프로그래밍'이라고 한다.

객체의 프로퍼티는 또한 '데이터 프로퍼티'와 '접근자 프로퍼티'로도 구분할 수 있다. 데이터 프로퍼티는 말 그대로 '데이터(값)'을 의미하고, 접근자 프로퍼티는 객체 내부에 있는 데이터(프로퍼티, 메서드)에 접근하여 조회(get) 또는 수정(set)할 수 있도록 돕는 프로퍼티다.

접근자 프로퍼티를 잘 활용하면 객체 내부의 정보를 은닉하거나 캡슐화해서 사용할 수 있고, 자바스크립트의 클래스에서 자주 사용된다.

[프로퍼티 톺아보기: 프로퍼티 vs 메서드, 프로퍼티 vs 변수](https://jaygo-dev.tistory.com/5)
[프로퍼티 톺아보기: 데이터 프로퍼티와 접근자 프로퍼티](https://jaygo-dev.tistory.com/6)


# 함수와 스코프
자바스크립트에서 함수는 객체다. 그리고, 생성자 함수는 객체를 생성하는 데 활용된다. `this`는 함수 내에 존재하지만 가리키는 대상은 객체다. 또, `this`를 통해 함수에서 함수가 호출된 환경이 되는 객체를 지칭할 수 있다. 여러 면에서 함수와 객체는 떼놓고 볼 수 없다.

함수는 함수 선언문과 함수 표현식, 그리고 화살표 함수 등 다양한 방식으로 선언 및 호출할 수 있다. 함수 선언문으로 선언한 함수는 호이스팅의 대상이 되고, 호이스팅 시 함수의 본문이 함께 끌어올려지지만, 함수 표현식은 변수가 호이스팅되고 변수에 할당될 함수 본문은 실제 런타임에 할당 및 동작한다. 그래서, 함수 선언문은 함수 선언-할당 전에 호출해도 정상적으로 동작하지만, 함수 표현식은 함수 선언-할당 전에 호출이 불가하다.

함수는 또한 실행 컨텍스트를 생성하고, 스코프의 범위를 결정하는 기준이 된다. 자바스크립트 엔진은 함수를 기준으로 실행 컨텍스트를 생성하며, 실행 컨텍스트의 렉시컬 환경 내부에 있는 환경 레코드가 스코프의 정체이기 때문에, 스코프는 기본적으로 함수를 기본으로 한다.

단, 블록 스코프가 적용되는 `let`과 `const`는 함수 내부의 실행 컨텍스트 안에서도 n개의 환경 레코드가 생성될 수 있으며 환경 레코드 기준으로 스코프가 구분된다. 이러한 동작을 만들어내기 위해 렉시컬 환경은 `VariableEnvironment`와 `LexicalEnvironment` 두 가지 컴포넌트로 구성된다(추가적으로, `this` 바인딩에 대한 정보도 보유한다).

함수 중 '콜백 함수'는 함수의 인자로 전달되는 함수를 의미한다. 콜백 함수의 호출은 콜백 함수를 인자로 받는 함수에게 있고, 콜백 함수를 사용하면 특정 함수의 동작을 함수를 통해 제어할 수 있다. 대표적으로 비동기 처리를 할 때 동작의 실행을 딜레이하기 위해 콜백 함수를 사용한다. 콜백 함수를 사용하면 A라는 동작이 완료되는 시점에 B라는 동작이 실행될 수 이 있도록 B 함수의 인자에 A를 콜백 함수로 넘기는 방식의 활용이 가능하다.

실행 컨텍스트의 환경 레코드 중 'OuterLexicalEnvironmentReference` 정보는 상위 렉시컬 환경(함수 실행 컨텍스트)을 가리키고, 해당 값을 통해 스코프 체인이 구현된다. 특정 함수의 스코프에서 사용된 식별자가 스코프 내에 선언된 정보가 없을 시, 자바스크립트 엔진은 자동으로 상위 스코프에 해당 식별자가 있는지 탐색하여 값을 참조한다. 이때, 스코프 체인은 단방향 링크드 리스트 형태로 구현되기 때문에 하위 스코프에서 상위 스코프로의 참조만 가능하고 반대는 불가능하다.


# 전역 변수의 문제점
지역 변수는 스코프가 좁기 때문에 변수명이 중복된다거나, 특정 변수가 메모리를 오랜 시간 점유하고 있어 메모리 효율이 나빠지는 문제가 덜하다. 반면, 전역 변수는 프로그램이 종료될 때까지 변수가 메모리 공간을 점유하고 있기 때문에 메모리 효율이 나쁘고, 변수명이 중복되어 의도치 않은 동작을 하게 될 우려가 커진다.

이러한 전역 변수의 문제점을 이해하고, 실제 변수를 사용할 땐 전역 변수 사용을 지양하는 게 좋다. 뿐만 아니라, 변수를 선언하고 사용하는 스코프를 최대한 좁게 가져가는 것이 바람직하고, 이외에도 JS 파일을 모듈로 쪼개서 사용해 서로의 스코프가 독립적일 수 있게 하는 방법을 사용하는 것도 전역 변수의 문제점을 해결하기 위한 대안 중 하나이다.


# `var` `let` `const`
`var`는 호이스팅 시 `undefined`가 자동 할당되고, `let`은 선언만 되고 초기화는 되지 않는다. `const`는 호이스팅 시 할당이 반드시 같이 이뤄져야 한다.

`var`는 재선언이 가능하지만, `let`과 `const`는 재선언이 불가하다. `let`은 재할당은 가능하지만, `const`는 재할당도 불가능하다.

`var`는 함수 스코프를 갖지만, `let`과 `const`는 블록 스코프를 갖는다. 따라서, 스코프 내에서 변수에 할당된 값의 예측 가능성을 높이기 위해 `var`보단 `let`이나 `const`를 사용하는 게 안전하다.

`var`, `let`, `const`의 동작 차이는 실행 컨텍스트에서 데이터를 관리하는 방식에 의해 차이가 생긴다. 

`var`가 환경 레코드 중 '객체 환경 레코드'에 저장되며, 객체의 프로퍼티로 등록되어 값이 할당되는 것 대비, `let`과 `const`는 선언적 환경 레코드에 저장되며 객체의 프로퍼티인 게 아니라 고유한 값을 저장된다. `var`의 스코프를 렉시컬 환경 중 `VariableEnvironment`에서 관리하는 것 대비, `let`과 `const`의 스코프는 렉시컬 환경 중 `LexicalEnvironment`에서 관리한다.

스코프 체인에 의한 스코프 관리 방식은 자바스크립트 초기부터 가능했지만, 실행 컨텍스트와 렉시컬 환경이라는 컨셉은 ES5부터 도입됐다고 한다. 그리고, `let`과 `const` 변수 선언자는 ES6부터 추가된 문법이다. 아마도, 실행 컨텍스트라는 게 설계된 배경에 이미 `var`가 가진 문제점과, `let`과 `const`를 사용한 문제 해결을 염두해둔 게 아닐까 싶다.

자바스크립트는 태생이 웹 애플리케이션에 한정되며, 그나마도 무거운 로직 처리는 서버에 모두 맡기고 단순한 DOM 조작 정도를 기대하고 만들어진 언어이다. 그러다보니 프로젝트 당 JS 코드의 분량이 많지도 않았고, 파일을 모듈로 쪼개서 독립적으로 관리하는 것도 불가능했기 때문에(모듈 시스템도 ES6에 추가된 문법임), 변수의 스코프 관리 이슈가 덜 크리티컬했을 수 있다. 

하지만, JS 생태계가 서버 사이드 어플리케이션까지 확장되고, 프론트엔드의 로직 처리 부담이 점점 커지면서, JS에서도 변수의 스코프 관리가 까다로워지는 상황이 생겨났다. 그러면서 실행 컨텍스트와 `let`, `const` 키워드 등이 추가됐다. 이러한 변화를 잘 고려해서, 가급적 기존 문법인 `var` 사용을 지양하고, `let`과 `const` 사용을 주로 해야한다.








