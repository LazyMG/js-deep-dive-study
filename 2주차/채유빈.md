# 목차

7. [객체 리터럴](#10장-객체-리터럴)
8. [원시 값의 불변성, 객체의 가변성](#11장-원시-값과-객체의-비교)
9. [함수](#12장-함수)
10. [스코프란?](#13장-스코프)
11. [전역 변수는 왜 위험할까?](#14장-전역-변수의-문제점)
12. [var vs. let vs. const](#15장-let-const-키워드와-블록-레벨-스코프)

<br>

# 10장. 객체 리터럴

## 객체란?

객체(object)는 **0개 이상의 프로퍼티로 구성된 집합**이며, 프로퍼티는 **키(key)-값(value) 쌍**으로 구성된다. 프로퍼티의 값으로는 자바스크립트에서 사용할 수 있는 모든 값이 가능하며, 프로퍼티 값이 함수인 경우 이를 **메서드(method)**라 부른다.

프로퍼티와 메서드를 역할에 따라 구분하면 다음과 같다.

- 프로퍼티: 객체의 **상태**를 나타내는 값(data)
- 메서드: 프로퍼티를 참조하고 조작할 수 있는 **동작**(behavior)

```jsx
let person = {
	age: 30,  // 프로퍼티 (키: age, 값: 30)
	name: 'dev'  // 프로퍼티 (키: name, 값: 'dev')
	getName: function() {  // 메서드 (키: getName, 값: 함수)
		return this.name;
	}
};
```

<br>

## 객체 다루기

### 객체 생성

자바스크립트는 프로토타입 기반 객체지향 언어로서, 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create
- 클래스(ES6)

> **프로토타입 기반?**
> 객체지향 프로그래밍의 한 형태의 갈래로, 객체를 **원형(프로토타입)**으로 하여 **복제(cloning)**의 과정을 통해 객체의 동작 방식을 다시 사용할 수 있게 하는 방식이다.
> 참고 링크 1) [자바스크립트는 왜 프로토타입을 선택했을까→](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)
> 참고 링크 2) [JavaScript: 프로토타입(prototype) 이해→](https://www.nextree.co.kr/p7323/)

그 중에 가장 일반적이고 간단한 방법은 **객체 리터럴**을 사용하는 방법이다.

```jsx
let person = {
  name: "kim",
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  },
};
```

> 객체 리터럴은 값으로 평가되는 표현식이다. 따라서 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.

<br>

### 프로퍼티

프로퍼티는 키와 값으로 구성된다고 했다. 프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 다음과 같다.

- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

만약 프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 되며, 이미 존재하는 프로퍼티 키를 중복해서 선언하면 앞선 프로퍼티를 나중에 선언한 프로퍼티가 덮어쓴다.

```jsx
var foo = {
  name: "kim",
  name: "park",
};

console.log(foo); // { name: "park" }
```

<br>

### 프로퍼티 접근

프로퍼티를 선언했다면, 이후 프로퍼티에 접근해서 값을 사용할 것이다. 프로퍼티에 접근하는 방법은 2가지가 있다.

- 마침표 표기법 (.)
- 대괄호 표기법 ([])

```jsx
var person = {
  name: "kim",
};

// 마침표 표기법에 의한 프로퍼티 접근
console.log(person.name);

// 대괄호 표기법에 의한 프로퍼티 접근
console.log(person["name"]);
```

만약 객체에 존재하지 않는 프로퍼티에 접근하면 `undefined`를 반환한다.

```jsx
var person = {
  name: "kim",
};

console.log(person.age); // undefined
```

<br>

### 프로퍼티 추가, 삭제

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되며, `delete` 연산자를 사용하여 삭제할 수 있다.

```jsx
var person = {
  name: "kim",
};

person.age = 20;

console.log(person); // { name: "kim", age: 20 }

delete person.age;

console.log(person); // { name: "kim" }
```

<br>

## 객체 리터럴 확장 기능(ES6)

ES6에서는 다음과 같은 객체 리터럴의 확장 기능을 제공한다.

### 프로퍼티 축약 표현

변수를 프로퍼티 값으로 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다.

```jsx
let x = 1,
  y = 2;

const obj = { x, y };

console.log(obj); // { x: 1, y: 2 }
```

<br>

### 계산된 프로퍼티 이름

문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다.

```jsx
const prefix = "prop";
let i = 0;

const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
};

console.log(obj); // { prop-1: 1, prop-2: 2 }
```

<br>

### 메서드 축약 표현

메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.

```jsx
// ES5
var obj = {
  sayHi: function () {
    console.log("Hi");
  },
};

// ES6
const obj = {
  sayHi() {
    console.log("Hi");
  },
};
```

<br>

# 11장. 원시 값과 객체의 비교

## 원시 값은 불변값이다

자바스크립트의 원시 타입의 값은 변경할 수 없는 **읽기 전용 값**이다. 이렇게 말하면 아래 코드처럼 원시 타입 변수는 값을 변경할 수 있지 않나? 라는 생각이 들 것이다.

```jsx
var num = 5;
num = 3;
```

그러나 제목을 다시 한 번 보자. 원시 ‘값’이 불변이라고 했다.

변수는 어떤 값을 저장하기 위해 확보한 메모리 공간을 말하고, 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 말한다.

변경 불가능한 것은 변수가 아니라 **값**이다.

```jsx
var num = 5;
num = 3;
```

값이 변경되지 않는다면, 위 코드는 어떻게 동작하게 될까?

원시 값을 할당한 변수에 새로운 원시 값을 재할당하면, 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, **변수는 새롭게 만들어진 원시 값을 가리킨다.** 기존의 메모리 공간에서 값이 변경되는 것이 아니다.

이러한 원시 값의 특성을 **불변셩(immutability)**라 하고, 불변성은 데이터의 신뢰성을 보장한다.

<br>

### 값에 의한 전달

불변성을 가지는 원시값을 복사하면 어떻게 될까?

```jsx
var score = 80;
var copy = score; // copy에는 score 변수의 값 80이 복사되어 할당된다.

console.log(score === copy); // true

score = 100;

console.log(score, copy); // 100, 80
```

copy에 score 변수의 값을 복사해서 할당한 뒤, score에 100을 재할당했다. 마지막 행에서 볼 수 있다시피 score는 재할당된 값인 100을, copy는 복사되었을 때의 값인 80을 그대로 가지고 있다.

이처럼 변수에 원시 값을 갖는 변수를 할당하면, 할당받는 변수에는 할당되는 변수의 원시 값이 변수에 전달된다.

이를 값에 의한 전달이라고 한다.

<br>

## 객체는 가변값이다

원시 값과 달리, 객체는 변경할 수 있는 값(mutable value)이다.

> 원시 값을 할당한 변수는 원시 값 자체를 값으로 가지지만, **객체를 할당한 변수는 객체가 실제로 저장된 메모리 공간 주소 그 자체를 가지고 있기 때문이다.** 변수는 이 참조 값을 통해 객체에 접근한다.

원시 값은 불변 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당을 해야 한다.

그러나, 객체는 가변값이므로 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.

코드로 보면 다음과 같다.

```jsx
var num = 5;
num = 3; // 재할당

var person = {
  name: "Kim",
};

// 객체의 재할당 없이 프로퍼티 값만 갱신
person.name = "Lee";
```

이때, 객체를 할당한 변수에 재할당을 하지 않았기 때문에 객체를 할당한 변수의 참조 값은 변경되지 않는다.

<br>

### 참조에 의한 전달

객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값**이 복사되어 전달된다.

이를 참조에 의한 전달이라 한다.

> ECMAScript 사양에 정의된 공식적인 용어는 아니다. 값의 종류에 따라 복사 시 동작이 달라지는 점을 설명하기 위해 다른 프로그래밍 언어에서 사용하는 개념을 가져왔다고 생각하면 된다.

```jsx
var person = {
  name: "Kim",
};

// 참조 값을 복사(얕은 복사)
var copy = person;
```

참조 값이 복사된다는 말은, person과 copy가 **동일한 하나의 객체를 공유**한다는 것과 같다. 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면, 다른 한쪽도 영향을 받는다.

```jsx
var person = {
  name: "Kim",
};

// 참조 값을 복사(얕은 복사)
var copy = person;

console.log(copy === person); // copy와 person은 동일한 객체를 참조한다.

copy.name = "Lee"; // copy를 통해 객체를 변경한다.

console.log(person); // { name: "Lee" }
console.log(person); // { name: "Lee" }
```

결국, 값에 의한 전달과 참조에 의한 전달은 **식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다**는 면에서는 동일하다.

그러나 메모리 공간에 저장되어 있는 값이 원시 값이냐, 참조 값이냐의 차이만 있을 뿐이다.

그리고 이 차이 때문에 값을 복사할 때 차이가 발생하며, 여기서 얕은 복사와 깊은 복사 개념도 등장한다.

얕은 복사와 깊은 복사는 추후 정리하도록 하겠다.

<br>

# 12장. 함수

## 함수를 왜 사용할까?

함수는 필요할 때 여러 번 호출할 수 있으므로, 반복되는 코드를 일일히 작성하지 않고 편하게 **재사용**할 수 있다.

또한, 코드의 중복을 억제하고 재사용성을 높이는 함수는 **유지보수의 편의성**을 높이고 **코드의 신뢰성**을 높이는 효과가 있다.

<br>

## 함수 리터럴

자바스크립트의 함수는 객체 타입의 값이다. 값은 리터럴로 생성할 수 있으므로, 함수도 함수 리터럴로 생성할 수 있다.

```jsx
function add(x, y) {
  return x + y;
}
```

함수 리터럴의 구성 요소에는 함수 이름, 매개변수 목록, 함수 몸체가 있으나 가장 중요한 특징은 **함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자**라는 것이다.

<br>

## 함수 정의 방식

자바스크립트에서 함수를 정의하는 방식에는 4가지가 있다.

- 함수 선언문
- 함수 표현식
- Function 생성자 함수
- 화살표 함수

<br>

### 함수 선언문

함수 리터럴과 동일한 형태를 가지는 함수 정의 방식이다.

```jsx
function add(x, y) {
  return x + y;
}
```

자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성한다. 이때 자바스크립트 엔진은 **생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.**

<br>

### 함수 표현식

자바스크립트의 함수는 객체 타입의 값이다. (일급 객체)

따라서 함수는 변수에 할당할 수 있으며, 이러한 함수 정의 방식을 함수 표현식이라고 한다.

```jsx
// 익명 함수 표현식 (함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.)
var add = function (x, y) {
  return x + y;
};

console.log(add(1, 2)); // 3

// 기명 함수 표현식
var minus = function foo(x, y) {
  return x - y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(minus(2, 1)); // 1
```

<br>

### Function 생성자 함수

일반적이지 않으며 바람직하지도 않다.

함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작하므로 웬만하면 사용을 지양하자.

```jsx
var add = new Function("x", "y", "return x + y");
```

<br>

### 화살표 함수

ES6에서 도입되었으며, `function` 키워드 대신 화살표(`⇒`)를 사용해 함수를 선언하는 방법이다.

화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식, prototype 프로퍼티 유무, arguments 객체 유무 등 다른 점이 많다.

```jsx
// 화살표 함수는 항상 익명 함수로 정의한다.
const add = (x, y) => x + y;
```

<br>

## 함수 호이스팅

함수 호이스팅이란, **함수 선언문**이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다.

```jsx
// 함수 참조
console.dir(add); // f add(x, y)

// 함수 호출
console.log(add(2, 5)); // 7

// 함수 선언문
function add(x, y) {
  return x + y;
}
```

위 코드와 같이 함수 선언문으로 정의한 함수는 함수 선언문 이전에 참조, 호출할 수 있다.

함수 선언문으로 함수를 정의하면 **런타임 이전에** 함수 객체가 생성되고, 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하여 생성된 함수 객체를 할당하기 때문이다.

변수 호이스팅과는 다음과 같은 차이점이 있다.

> var 키워드를 사용한 변수 선언문은 `undefined`로 초기화되지만, 함수 선언문을 통해 암묵적으로 생성된 식별자는 `함수 객체`로 초기화되므로 **호출**이 가능하다.

따라서, 변수에 함수 리터럴이 할당되는 **함수 표현식**으로 함수를 정의하는 경우 함수 호이스팅이 아니라 **변수 호이스팅**이 발생한다.

> 변수 할당문인 함수 리터럴도 런타임에 평가되기 때문이다.

```jsx
// 함수 참조
console.dir(sub); // undefined

// 함수 호출
// undefined를 호출하기 때문에 타입 에러가 발생한다.
console.log(sub(3, 2)); // TypeError: sub is not a function

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

<br>

## 다양한 함수의 형태

- 즉시 실행 함수
  ```jsx
  (function () {
    var a = 3;
    var b = 5;
    return a * b;
  })();
  ```
- 재귀 함수
  ```jsx
  function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
  }
  ```
- 중첩 함수
  - 함수 내부에 정의된 함수
  - 중첩 함수를 포함하는 함수는 **외부 함수**라고 한다.
  ```jsx
  function outer() {
  	var x = 1;

  	// 중첩 함수: 주로 자신을 포함하는 외부 함수(여기서는 outer)를 돕는 헬퍼 함수의 역할을 한다.
  	var y = 2;
  	console.log(x + y);  // 3
  	}

  	inner();
  }

  outer();
  ```
- 콜백 함수
  - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
  - 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 **고차 함수**라고 한다.
  - 중첩 함수는 함수 내부에 고정되어 있지만, 콜백 함수는 함수 외부에서 고차 함수 내부로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다.
  ```jsx
  // 콜백 함수를 사용하는 고차 함수 map
  var res = [1, 2, 3].map(function (item) {
    return item * 2;
  });

  console.log(res); // [2, 4, 6]
  ```
- 순수 함수와 비순수 함수
  - 순수 함수: 부수효과가 없는 함수. 어떤 외부 상태에 의존하지도 않고 외부 상태를 변경하지도 않는다.
  - 비순수 함수: 부수효과가 있는 함수. 외부 상태에 의존하거나 외부 상태를 변경한다.
  > 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워지므로, 함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋다.

<br>

## 함수형 프로그래밍

함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 **부수 효과를 최소화**해서 **불변성을 지향**하는 프로그래밍 패러다임이다.

부수 효과를 최소화한다는 것은 그 자체로 복잡성을 줄일 수 잇으며, 오류 또한 최소화할 수 있다.

자바스크립트는 멀티 패러다임 언어로, 객체지향 프로그래밍 뿐만 아니라 함수형 프로그래밍을 적극적으로 활용하고 있다.

<br>

# 13장. 스코프

## 스코프란?

스코프란, **식별자(변수 이름, 함수 이름, 클래스 이름 등)가 유효한 범위**를 말한다. 모든 식별자는 자신이 **선언된 위치**에 의해 유효 범위가 결정된다.

스코프는 전역 스코프와 지역 스코프로 구분할 수 있다.

|      | 설명                  | 스코프      | 변수      |
| ---- | --------------------- | ----------- | --------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | **함수 몸체 내부**    | 지역 스코프 | 지역 변수 |

<br>

### 전역 변수

전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수(global variable)가 되고, **전역 변수는 어디서든 참조할 수 있다.**

<br>

### 지역 변수

지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수(local variable)가 된다. 지역 변수는 **자신의 지역 스코프와 하위 지역 스코프에서 유효**하다.

<br>

## 스코프 체인

스코프는 함수의 중첩에 의해 계층적인 구조를 가진다. 모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프다.

이렇게 **스코프가 계층적으로 연결된 것**을 스코프 체인이라고 한다.

식별자를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 **변수를 참조하는 코드의 스코프부터 상위 스코프 방향으로 이동**하며 선언된 식별자를 검색한다.

```jsx
var x = "x";

function local() {
  var y = "y";

  console.log(x); // x, 지역 스코프에 변수 x가 없기 때문에 상위 스코프인 전역에서 검색하고 참조한다.
  console.log(y); // y
}
```

<br>

## 함수 레벨 스코프

지역 스코프를 만드는 지역은 **함수 몸체 내부**이다.

즉, **함수에 의해서 지역 스코프가 생성된다**는 의미이다.

이런 특성을 함수 레벨 스코프라고 하는데, 블록 레벨 스코프의 특성을 가지는 다른 프로그래밍 언어와 자바스크립트의 큰 차이점이다.

> **블록 레벨 스코프?**
> 모든 코드 블록(if, for, while 등)이 지역 스코프를 만드는 특성

var 키워드로 선언된 변수는 **함수의 코드 블록만을 지역 스코프로 인정**한다.

```jsx
var x = 1;

if (true) {
  var x = 10; // 함수가 아니라 코드 블록 내에서 선언된 변수이기 때문에 전역 변수이다.
}

console.log(x); // 10
```

<br>

## 렉시컬 스코프

함수의 상위 스코프를 결정하는 방식에는 두 가지가 있다.

1. 동적 스코프
   - 함수가 **호출**된 위치에 따라 함수의 상위 스코프를 결정한다.
2. 정적 스코프(=렉시컬 스코프)
   - 함수가 **정의**된 위치에 따라 함수의 상위 스코프를 결정한다.

자바스크립트는 렉시컬 스코프를 따른다.

> 즉, 함수의 상위 스코프는 언제나 자신이 **정의된** 스코프다.

아래 예시를 보자.

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 10
bar(); // 10
```

함수는 정의된 위치에 따라 함수의 상위 스코프를 결정하기 때문에, 함수의 상위 스코프는 언제나 자신이 정의된 스코프라고 했다.

`bar()` 함수는 전역에서 정의된 함수다. 따라서 콘솔에는 모두 10이 찍힌다.

<br>

# 14장. 전역 변수의 문제점

## 어디서든 참조하고 변경할 수 있다

위 제목 그대로, 전역 변수는 어디서든 참조하고 변경할 수 있다. 이는 예측 불가능한 동작을 낳기도 한다.

```jsx
var x = "global";

// ... 수많은 코드들

function foo() {
  var x = "local";
}

function getGlobal() {
  console.log(x); // local
}

getGlobal();
```

만약 위와 같이, 전역 변수 x를 선언했는데 나중에 그 사실을 모르고 다시 선언했다고 하자. getGlobal() 함수를 실행했을 때 기대한 값은 ‘global’이었는데, 중간에 ‘local’로 바뀌어버린 것이다.

이렇듯 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고, 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.

<br>

## 생명 주기가 길다

변수는 자신이 선언된 위치에서 생성되고 소멸한다.

전역 코드는 코드가 로드되자마자 곧바로 해석되고 실행되며, 더 이상 실행할 문이 없을 때 종료한다.

var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되며, **따라서 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.**

만약 브라우저 환경에서 선언된 전역 변수라면, 전역 객체 `window`의 프로퍼티가 되고, `window` 객체는 웹페이지를 열었을 때 만들어지고 닫기 전까지 유효하다.

**반면 지역 변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때까지만 유효하다.** 따라서 지역 변수는 전역 변수보다 생명 주기가 훨씬 짧으며, 이는 지역 변수의 상태를 변경할 수 있는 시간도 짧고 기회도 적다는 뜻이다.

거기에다 메모리 리소스도 짧게 점유하는 편이니 꼭 필요한 경우가 아니라면 지역 변수를 사용하는 것이 좋다.

<br>

## 검색 속도가 가장 느리다

전역 변수는 스코프 체인 상에서 종점(최상위)에 존재한다.

스코프 체인을 검색하는 방향은 '하위 → 상위'이기 때문에, 식별자를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것이다.

검색 속도의 차이가 크지는 않지만 분명히 존재한다.

<br>

## 네임스페이스가 오염된다

자바스크립트는 파일이 분리되어 있다고 해도, 하나의 전역 스코프를 공유한다.

따라서 다른 파일 내에서 같은 이름으로 선언된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우, 예상치 못한 결과가 나타날 수 있다.

<br>

## 전역 변수의 사용을 억제하는 방법

1. 즉시 실행 함수
2. 네임스페이스 객체
3. 모듈 패턴
4. ES6 모듈

<br>

# 15장. let, const 키워드와 블록 레벨 스코프

ES6에서는 var 키워드의 단점을 보완하기 위해 let, const 키워드를 도입했다. var 키워드의 단점에 대해 먼저 알아보자.

<br>

## var 키워드의 단점

### 변수 중복 선언 허용

var 키워드로 변수를 선언 시, 중복 선언이 허용되므로 만약 변수가 이미 선언되어 있는지 모르고 중복 선언 후 값까지 할당했다면 의도치 않게 기존 변수 값이 변경되는 부작용이 발생한다.

```jsx
var x = 1;

// 중복된 선언은 자바스크립트에 의해 var 키워드가 없는 것처럼 동작한다.
var x = 100;

console.log(x); // 100
```

<br>

### 함수 레벨 스코프

var 키워드로 선언한 변수는 오로지 [함수의 코드 블록만을 지역 스코프로 인정한다고 했다.](https://velog.io/@yuuub/%EC%8A%A4%EC%BD%94%ED%94%84scope%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90#%ED%95%A8%EC%88%98-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84)

```jsx
var x = 1;

if (true) {
  var x = 3;
}

console.log(3);
```

위 코드처럼 의도치 않게 전역 변수가 중복 선언될 수 있다.

<br>

### 변수 호이스팅

변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 그러나 직관적으로 이해되는 동작이 아니기 때문에 가독성을 떨어뜨리고 디버깅을 어렵게 만든다.

```jsx
console.log(foo); // undefined

foo = 123;

console.log(foo); // 123

// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행된다.
var foo;
```

<br>

## let 키워드

var 키워드의 단점을 극복하기 위해 나왔으니, var 키워드와의 차이점을 중심으로 살펴보자.

<br>

### 변수 중복 선언 금지

let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러(Syntax Error)가 발생한다.

```jsx
let x = 1;
let x = 100; // Syntax Error
```

<br>

### 블록 레벨 스코프

let 키워드로 선언한 변수는 함수 레벨 스코프 대신 블록 레벨 스코프를 따른다.

```jsx
let foo = 1; // global

{
  let bar = 2; // local
}

console.log(foo); // 1
console.log(bar); // ReferenceError: bar is not defined
```

<br>

### 변수 호이스팅

let 키워드로 선언한 변수는 변수 호이스팅이 **발생하지 않는 것처럼** 동작한다.

```jsx
console.log(foo); // ReferenceError: foo is not defined
let foo;
```

var 키워드로 변수를 선언하면 다음 두 가지 단계가 런타임 이전에 **한 번에** 진행된다.

1. 선언 단계: 실행 컨텍스트에 변수 식별자를 등록해 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계: `undefined`로 변수를 초기화한다.

이와 달리, let 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.

> 선언 단계는 자바스크립트에 의해 런타임 이전에 암묵적으로 실행되지만, **초기화 단계는 변수 선언문에 도달했을 때 실행된다.**

이때 스코프의 시작 지점부터 변수 선언문(초기화 단계 시작 지점)까지 변수를 참조할 수 없는데, 이 구간을 **TDZ**(Temporal Dead Zone)이라고 부른다.

이 TDZ 덕분에 변수 호이스팅이 발생하지 않는 것처럼 보인다.

그렇다면 실제로 호이스팅이 발생하긴 하는걸까? 아래 코드를 보자.

```jsx
let foo = 1;

{
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  let foo = 2;
}
```

만약 변수 호이스팅이 발생하지 않는다면, 위 코드를 실행하면 콘솔에 1이 출력되어야 할 것이다.

그러나 지역 변수인 foo 변수도 여전히 호이스팅이 발생하기 때문에 참조 에러가 발생하는 것을 확인할 수 있다.

<br>

## const 키워드

const 키워드는 let 키워드와 마찬가지로 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

let 키워드와 다른 점에 대해 알아보자.

<br>

### 선언과 동시에 초기화해야 한다

const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.

그렇지 않으면 문법 에러가 발생한다.

```jsx
const foo = 1;
const bar;  // SyntaxError: Missing initializer in const declaration
```

<br>

### 재할당할 수 없다

재할당 시 타입 에러가 발생한다.

```jsx
const foo = 1;
foo = 2; // TypeError: Assignment to constant variable.
```

<br>

### 상수로 사용할 수 있다

const 키워드로 선언한 변수에 원시 값을 할당한 경우, 원시 값은 불변값이고 const 키워드에 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.

상수로 ‘사용할 수 있다’라는 건, 상수로 사용하지 않을 수도 있다는 뜻이다.

바로 const 키워드로 선언된 변수에 객체를 할당한 경우를 말하는데, 이때는 값을 변경할 수 있기 때문이다.

```jsx
const person = {
  name: "Kim",
};

person.name = "Lee";

console.log(person); // { name: "Lee" }
```

진정한 의미의 상수로 사용하려면 아래처럼 원시 값을 할당했을 때 가능하다.

```jsx
const TAX_RATE = 0.3;

let preTaxPrice = 100;

let afterTaxPrice = preTaxPrice + preTaxPrice * TAX_RATE;
```

<br>

## var vs. let vs. const

마지막으로 표로 정리해보겠다.

|       | 중복 선언 | 스코프           | 변수 호이스팅                                    | 용도                               |
| ----- | --------- | ---------------- | ------------------------------------------------ | ---------------------------------- |
| var   | 가능      | 함수 레벨 스코프 | 발생                                             | 사용 자제                          |
| let   | 불가능    | 블록 레벨 스코프 | 발생 (TDZ로 인해 발생하지 않는 '것처럼' 보인다.) | 재할당이 필요한 경우에 한정해 사용 |
| const | 불가능    | 블록 레벨 스코프 | 발생 (TDZ로 인해 발생하지 않는 '것처럼' 보인다.) | 기본적으로 사용                    |

<br>
